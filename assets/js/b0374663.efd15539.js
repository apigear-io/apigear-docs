"use strict";(self.webpackChunkapigear=self.webpackChunkapigear||[]).push([[8060],{28453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(96540);const c={},d=t.createContext(c);function r(e){const n=t.useContext(d);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),t.createElement(d.Provider,{value:n},e.children)}},55524:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>t,toc:()=>i});const t=JSON.parse('{"id":"advanced/maker/rules","title":"Rules Document","description":"The rules document defines the context for each document to be transformed.","source":"@site/docs/advanced/maker/rules.md","sourceDirName":"advanced/maker","slug":"/advanced/maker/rules","permalink":"/docs/advanced/maker/rules","draft":false,"unlisted":false,"editUrl":"https://github.com/apigear-io/apigear-docs/edit/main/docs/advanced/maker/rules.md","tags":[],"version":"current","lastUpdatedAt":1675172564000,"sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Symbol Reference","permalink":"/docs/advanced/maker/symbols"},"next":{"title":"Service Simulation","permalink":"/docs/advanced/simulation/intro"}}');var c=s(74848),d=s(28453);const r={sidebar_position:6},l="Rules Document",a={},i=[{value:"Features",id:"features",level:2},{value:"Feature dependencies",id:"feature-dependencies",level:3},{value:"Scopes",id:"scopes",level:2},{value:"Match logic",id:"match-logic",level:3},{value:"Documents",id:"documents",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,d.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(n.header,{children:(0,c.jsx)(n.h1,{id:"rules-document",children:"Rules Document"})}),"\n",(0,c.jsx)(n.p,{children:"The rules document defines the context for each document to be transformed."}),"\n",(0,c.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,c.jsx)(n.p,{children:"Features are an isolated part of the code generator. When running the code generator features can be enabled and disable."}),"\n",(0,c.jsx)(n.p,{children:"A feature is declared by name inside the features root tag."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: feature1\n  - name: feature2\n"})}),"\n",(0,c.jsx)(n.p,{children:"A feature can contain a prefix target path as also a scope for documents."}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: feature1\n    prefix: {{module.name}}/\n"})}),"\n",(0,c.jsxs)(n.p,{children:["Typical features are ",(0,c.jsx)(n.code,{children:"api"}),", ",(0,c.jsx)(n.code,{children:"scaffold"})," but also protocols like ",(0,c.jsx)(n.code,{children:"http"}),", ",(0,c.jsx)(n.code,{children:"wamp"}),"."]}),"\n",(0,c.jsx)(n.p,{children:"A feature can have these properties:"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"needs"}),": defines feature flag which other features need to be enabled"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"prefix"}),": defines a prefix output path"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"scope"}),": defines a scope for documents with a match expression (e.g. ",(0,c.jsx)(n.code,{children:"system"}),", ",(0,c.jsx)(n.code,{children:"module"}),", ",(0,c.jsx)(n.code,{children:"interface"}),", ",(0,c.jsx)(n.code,{children:"struct"}),", ",(0,c.jsx)(n.code,{children:"enum"}),")"]}),"\n"]}),"\n",(0,c.jsx)(n.h3,{id:"feature-dependencies",children:"Feature dependencies"}),"\n",(0,c.jsxs)(n.p,{children:["Needs allows to define a dependency between features. For example the ",(0,c.jsx)(n.code,{children:"scaffold"})," feature needs the ",(0,c.jsx)(n.code,{children:"api"})," feature to be enabled."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: api\n  - name: scaffold\n    needs:\n      - api\n"})}),"\n",(0,c.jsx)(n.h2,{id:"scopes",children:"Scopes"}),"\n",(0,c.jsxs)(n.p,{children:["A scope defined the context for the template for language for the defined documents. The context defines the available objects available inside the template language. For example a module scope will always have defined ",(0,c.jsx)(n.code,{children:"features"}),", ",(0,c.jsx)(n.code,{children:"system"})," and ",(0,c.jsx)(n.code,{children:"module"})," in the template document."]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: feature1\n    scopes:\n      - match: system\n        documents:\n          - { source: system.go, target: system.go }\n      - match: module\n        documents:\n          - { source: module.go, target: module.go }\n      - match: interface\n        documents:\n          - { source: interface.go, target: interface.go }\n      - match: struct\n        documents:\n          - { source: struct.go, target: struct.go }\n      - match: enum\n        documents:\n          - { source: enum.go, target: enum.go }\n"})}),"\n",(0,c.jsxs)(n.p,{children:["A scope with the match ",(0,c.jsx)(n.code,{children:"interface"})," iterates over all interfaces in all modules and has defined a context with ",(0,c.jsx)(n.code,{children:"features"}),", ",(0,c.jsx)(n.code,{children:"system"})," and ",(0,c.jsx)(n.code,{children:"module"})," and the current ",(0,c.jsx)(n.code,{children:"interface"})," in it."]}),"\n",(0,c.jsx)(n.h3,{id:"match-logic",children:"Match logic"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:["match: ",(0,c.jsx)(n.code,{children:"system"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"called once for the system"}),"\n",(0,c.jsxs)(n.li,{children:["context => ",(0,c.jsx)(n.code,{children:"{ features, system }"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["match: ",(0,c.jsx)(n.code,{children:"module"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"called for each module"}),"\n",(0,c.jsxs)(n.li,{children:["context => ",(0,c.jsx)(n.code,{children:"{ features, system, module }"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["match: ",(0,c.jsx)(n.code,{children:"interface"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"called once per interface in all modules"}),"\n",(0,c.jsxs)(n.li,{children:["context => ",(0,c.jsx)(n.code,{children:"{ features, system, module, interface }"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["match: ",(0,c.jsx)(n.code,{children:"struct"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"called once per struct in all modules"}),"\n",(0,c.jsxs)(n.li,{children:["context => ",(0,c.jsx)(n.code,{children:"{ features, system, module, struct }"})]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.li,{children:["match: ",(0,c.jsx)(n.code,{children:"enum"}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:"called once per enum in all modules"}),"\n",(0,c.jsxs)(n.li,{children:["context => ",(0,c.jsx)(n.code,{children:"{ features, system, module, enum }"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsx)(n.h2,{id:"documents",children:"Documents"}),"\n",(0,c.jsx)(n.p,{children:"A document defines the source template and the target where to write the document."}),"\n",(0,c.jsx)(n.p,{children:"The document define the source, target and some additional flags for writing."}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"source"}),": source path inside the templates directory."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"target"}),": target template string inside the output directory."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"force"}),": if true, the document will be forced to be overwritten when re-generated."]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:"raw"}),": if true, document will be just copied and not treated as template. Raw if off by default."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,c.jsx)(n,{...e,children:(0,c.jsx)(o,{...e})}):o(e)}}}]);