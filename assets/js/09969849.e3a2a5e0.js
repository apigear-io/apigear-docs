"use strict";(self.webpackChunkapigear=self.webpackChunkapigear||[]).push([[6209],{2503:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"advanced/protocols/mapping","title":"Protocol Mappings","description":"ObjectAPI describes object communication patterns based on simple to use protocols. These communication patterns can be mapped to other communication patterns.","source":"@site/docs/advanced/protocols/mapping.md","sourceDirName":"advanced/protocols","slug":"/advanced/protocols/mapping","permalink":"/docs/advanced/protocols/mapping","draft":false,"unlisted":false,"editUrl":"https://github.com/apigear-io/apigear-docs/edit/main/docs/advanced/protocols/mapping.md","tags":[],"version":"current","lastUpdatedAt":1727808477000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"docsSidebar","previous":{"title":"API Stimulation (experimental)","permalink":"/docs/advanced/stimulation/intro"},"next":{"title":"Introduction","permalink":"/docs/advanced/protocols/objectlink/intro"}}');var i=t(74848),a=t(28453);const o={sidebar_position:7},c="Protocol Mappings",r={},l=[{value:"API Types",id:"api-types",level:2},{value:"REST based APIs",id:"rest-based-apis",level:3},{value:"Message based APIs",id:"message-based-apis",level:3},{value:"Object based APIs",id:"object-based-apis",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",mermaid:"mermaid",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"protocol-mappings",children:"Protocol Mappings"})}),"\n",(0,i.jsx)(n.p,{children:"ObjectAPI describes object communication patterns based on simple to use protocols. These communication patterns can be mapped to other communication patterns."}),"\n",(0,i.jsx)(n.h2,{id:"api-types",children:"API Types"}),"\n",(0,i.jsx)(n.p,{children:"There exists currently several API types, like REST, Message Based or RPC. ObjectAPI supports a mixture of these."}),"\n",(0,i.jsx)(n.h3,{id:"rest-based-apis",children:"REST based APIs"}),"\n",(0,i.jsx)(n.p,{children:"REST API is about browsing data but the underlying nature of the protocol is HTTP. HTTP is a request/response protocol and as such is architecture wise next to RPC. REST itself defines an architectural style on top of HTTP."}),"\n",(0,i.jsx)(n.p,{children:"For example to increment a value this logic would be in REST like this."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n  client->>service: get /counter/$id\n  client->>client: increment\n  client--\x3eservice: put /counter/$id"}),"\n",(0,i.jsx)(n.p,{children:"We first fetch the counter state, than increment the count value and push back the result. The logic is on the client side and the service mostly manages data."}),"\n",(0,i.jsx)(n.p,{children:"A typical API would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const client = new HttpClient();\nconst data = await client.get("/counter/$id");\ndata.count += 1;\nawait client.put("/counter/$id");\n'})}),"\n",(0,i.jsx)(n.p,{children:"Often these kind of APIs makes it hard in complex logic driven services to validate operations and data."}),"\n",(0,i.jsx)(n.h3,{id:"message-based-apis",children:"Message based APIs"}),"\n",(0,i.jsx)(n.p,{children:"Message based APIs are typically realized using a message broker. The broker is responsible to ensure all messages are delivered to the subscribed or registered peers."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n  client->>broker: subscribe '/counter/$id'\n  client->>broker: publish 'counter/$id/increment'\n  broker->>client: publish '/counter/$id/'"}),"\n",(0,i.jsx)(n.p,{children:"First we would subscribe to and interface state changes. Then we would publish the increment signal and wait for changes on the interface state. The changes are announces by the service via the broker."}),"\n",(0,i.jsx)(n.p,{children:"A typical message based client would look like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:'const client = new MessageClient();\nclient.subscribe("/counter/$id");\nclient.on("/counter/$id", (v) => {\n  console.log(v);\n});\nclient.publish("/counter/$id/increment");\n'})}),"\n",(0,i.jsx)(n.h3,{id:"object-based-apis",children:"Object based APIs"}),"\n",(0,i.jsx)(n.p,{children:"Object based APIs focus on the developer API and take care of the internal mapping to the different protocol types. Interface properties will be typically automatically synced and signals will allow service side notifications to the clients."}),"\n",(0,i.jsx)(n.mermaid,{value:"sequenceDiagram\n  client->>service: increment\n  service->>service: increment\n  service->>client: sync state"}),"\n",(0,i.jsx)(n.p,{children:"The API for this would look like this."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const client = new CounterClient();\nclient.on((s) => {\n  console.log(s.count);\n});\nawait client.increment();\n"})}),"\n",(0,i.jsx)(n.p,{children:"First we register a callback when the interface state changes. Then we call the operation, as we defined an object API the API feels and works as developers would expect this."}),"\n",(0,i.jsx)(n.p,{children:"This makes it much nicer and easier to use the API inside your application. The\nThe API patterns is also extended to the service side, where service calls end into an API which looks very mich like the defined ObjectAPI."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>c});var s=t(96540);const i={},a=s.createContext(i);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);