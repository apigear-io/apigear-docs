"use strict";(self.webpackChunkapigear=self.webpackChunkapigear||[]).push([[8060],{6105:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>l,toc:()=>a});var t=s(4848),c=s(8453);const d={sidebar_position:6},r="Rules Document",l={id:"advanced/maker/rules",title:"Rules Document",description:"The rules document defines the context for each document to be transformed.",source:"@site/docs/advanced/maker/rules.md",sourceDirName:"advanced/maker",slug:"/advanced/maker/rules",permalink:"/docs/advanced/maker/rules",draft:!1,unlisted:!1,editUrl:"https://github.com/apigear-io/apigear-docs/edit/main/docs/advanced/maker/rules.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"docsSidebar",previous:{title:"Symbol Reference",permalink:"/docs/advanced/maker/symbols"},next:{title:"API Monitoring",permalink:"/docs/category/api-monitoring"}},i={},a=[{value:"Features",id:"features",level:2},{value:"Feature dependencies",id:"feature-dependencies",level:3},{value:"Scopes",id:"scopes",level:2},{value:"Match logic",id:"match-logic",level:3},{value:"Documents",id:"documents",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,c.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"rules-document",children:"Rules Document"}),"\n",(0,t.jsx)(n.p,{children:"The rules document defines the context for each document to be transformed."}),"\n",(0,t.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,t.jsx)(n.p,{children:"Features are an isolated part of the code generator. When running the code generator features can be enabled and disable."}),"\n",(0,t.jsx)(n.p,{children:"A feature is declared by name inside the features root tag."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: feature1\n  - name: feature2\n"})}),"\n",(0,t.jsx)(n.p,{children:"A feature can contain a prefix target path as also a scope for documents."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: feature1\n    prefix: {{module.name}}/\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Typical features are ",(0,t.jsx)(n.code,{children:"api"}),", ",(0,t.jsx)(n.code,{children:"scaffold"})," but also protocols like ",(0,t.jsx)(n.code,{children:"http"}),", ",(0,t.jsx)(n.code,{children:"wamp"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"A feature can have these properties:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"needs"}),": defines feature flag which other features need to be enabled"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"prefix"}),": defines a prefix output path"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"scope"}),": defines a scope for documents with a match expression (e.g. ",(0,t.jsx)(n.code,{children:"system"}),", ",(0,t.jsx)(n.code,{children:"module"}),", ",(0,t.jsx)(n.code,{children:"interface"}),", ",(0,t.jsx)(n.code,{children:"struct"}),", ",(0,t.jsx)(n.code,{children:"enum"}),")"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"feature-dependencies",children:"Feature dependencies"}),"\n",(0,t.jsxs)(n.p,{children:["Needs allows to define a dependency between features. For example the ",(0,t.jsx)(n.code,{children:"scaffold"})," feature needs the ",(0,t.jsx)(n.code,{children:"api"})," feature to be enabled."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: api\n  - name: scaffold\n    needs:\n      - api\n"})}),"\n",(0,t.jsx)(n.h2,{id:"scopes",children:"Scopes"}),"\n",(0,t.jsxs)(n.p,{children:["A scope defined the context for the template for language for the defined documents. The context defines the available objects available inside the template language. For example a module scope will always have defined ",(0,t.jsx)(n.code,{children:"features"}),", ",(0,t.jsx)(n.code,{children:"system"})," and ",(0,t.jsx)(n.code,{children:"module"})," in the template document."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"features:\n  - name: feature1\n    scopes:\n      - match: system\n        documents:\n          - { source: system.go, target: system.go }\n      - match: module\n        documents:\n          - { source: module.go, target: module.go }\n      - match: interface\n        documents:\n          - { source: interface.go, target: interface.go }\n      - match: struct\n        documents:\n          - { source: struct.go, target: struct.go }\n      - match: enum\n        documents:\n          - { source: enum.go, target: enum.go }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["A scope with the match ",(0,t.jsx)(n.code,{children:"interface"})," iterates over all interfaces in all modules and has defined a context with ",(0,t.jsx)(n.code,{children:"features"}),", ",(0,t.jsx)(n.code,{children:"system"})," and ",(0,t.jsx)(n.code,{children:"module"})," and the current ",(0,t.jsx)(n.code,{children:"interface"})," in it."]}),"\n",(0,t.jsx)(n.h3,{id:"match-logic",children:"Match logic"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["match: ",(0,t.jsx)(n.code,{children:"system"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"called once for the system"}),"\n",(0,t.jsxs)(n.li,{children:["context => ",(0,t.jsx)(n.code,{children:"{ features, system }"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["match: ",(0,t.jsx)(n.code,{children:"module"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"called for each module"}),"\n",(0,t.jsxs)(n.li,{children:["context => ",(0,t.jsx)(n.code,{children:"{ features, system, module }"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["match: ",(0,t.jsx)(n.code,{children:"interface"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"called once per interface in all modules"}),"\n",(0,t.jsxs)(n.li,{children:["context => ",(0,t.jsx)(n.code,{children:"{ features, system, module, interface }"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["match: ",(0,t.jsx)(n.code,{children:"struct"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"called once per struct in all modules"}),"\n",(0,t.jsxs)(n.li,{children:["context => ",(0,t.jsx)(n.code,{children:"{ features, system, module, struct }"})]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["match: ",(0,t.jsx)(n.code,{children:"enum"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"called once per enum in all modules"}),"\n",(0,t.jsxs)(n.li,{children:["context => ",(0,t.jsx)(n.code,{children:"{ features, system, module, enum }"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"documents",children:"Documents"}),"\n",(0,t.jsx)(n.p,{children:"A document defines the source template and the target where to write the document."}),"\n",(0,t.jsx)(n.p,{children:"The document define the source, target and some additional flags for writing."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"source"}),": source path inside the templates directory."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"target"}),": target template string inside the output directory."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"force"}),": if true, the document will be forced to be overwritten when re-generated."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"raw"}),": if true, document will be just copied and not treated as template. Raw if off by default."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,c.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(o,{...e})}):o(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>l});var t=s(6540);const c={},d=t.createContext(c);function r(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:r(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);