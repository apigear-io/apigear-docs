{"searchDocs":[{"title":"API surface for objects","type":0,"sectionRef":"#","url":"/blog/api-surface","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#properties","content":" Properties are the state of an object. They can be read and written and notify users about changes. Properties can be of any type.  interface HeatingSystem { temperature: float }   In the example above the temperature property is of type float. The type can be any type that is supported by the IDL. The type can be a primitive type or a complex type. A primitive type can be one of the following:  int : integer valuefloat : floating point valuestring : string valuebool : boolean value  Types can also be arrays. To define arrays of a type just append the [] to the type (for example int[]).  ","version":null,"tagName":"h2"},{"title":"Operations​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#operations","content":" Operations are functions that can be called on an object. They can be synchronous or asynchronous. Operations can receive parameters and return a value.  interface HeatingSystem { setTemperature(float temperature) }   In the example above the setTemperature operation receives a parameter of type float. The operation does not return a value.  ","version":null,"tagName":"h2"},{"title":"Signals​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#signals","content":" Signals are events that can be emitted by an object. They can be received by users of the object.  interface HeatingSystem { signal maxTemperatureReached() }   In the example above the maxTemperatureReached signal does not receive any parameters.  ","version":null,"tagName":"h2"},{"title":"Structures​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#structures","content":" Different than objects which can be interacted with, structures are just data structures that can be used to send complex information between objects. A structure is defined as follows:  struct Struct1 {}   A struct can have fields of any type.  ","version":null,"tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#enumerations","content":" An enumeration is a set of named values. An enumeration is defined as follows:  enum Enum1 { value1 value2 }   An enumeration can be used as a type for properties, operations and signals.  ","version":null,"tagName":"h2"},{"title":"Modules​","type":1,"pageTitle":"API surface for objects","url":"/blog/api-surface#modules","content":" A module is a collection of objects, structures and enumerations. A module is defined as follows:  module name version interface Name {}   The version of a module is a string that follows the semver format. The version of a module is optional. If no version is specified the version is 0.0.0.  Working with the API surface  When designing an API surface it is important to keep the following in mind: ","version":null,"tagName":"h2"},{"title":"Rules Document","type":0,"sectionRef":"#","url":"/docs/advanced/maker/rules","content":"","keywords":"","version":"Next"},{"title":"Features​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#features","content":" Features are an isolated part of the code generator. When running the code generator features can be enabled and disable.  A feature is declared by name inside the features root tag.  features: - name: feature1 - name: feature2   A feature can contain a prefix target path as also a scope for documents.  features: - name: feature1 prefix: {{module.name}}/   Typical features are api, scaffold but also protocols like http, wamp.  A feature can have these properties:  needs: defines feature flag which other features need to be enabledprefix: defines a prefix output pathscope: defines a scope for documents with a match expression (e.g. system, module, interface, struct, enum)  ","version":"Next","tagName":"h2"},{"title":"Feature dependencies​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#feature-dependencies","content":" Needs allows to define a dependency between features. For example the scaffold feature needs the api feature to be enabled.  features: - name: api - name: scaffold needs: - api   ","version":"Next","tagName":"h3"},{"title":"Scopes​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#scopes","content":" A scope defined the context for the template for language for the defined documents. The context defines the available objects available inside the template language. For example a module scope will always have defined features, system and module in the template document.  features: - name: feature1 scopes: - match: system documents: - { source: system.go, target: system.go } - match: module documents: - { source: module.go, target: module.go } - match: interface documents: - { source: interface.go, target: interface.go } - match: struct documents: - { source: struct.go, target: struct.go } - match: enum documents: - { source: enum.go, target: enum.go }   A scope with the match interface iterates over all interfaces in all modules and has defined a context with features, system and module and the current interface in it.  ","version":"Next","tagName":"h2"},{"title":"Match logic​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#match-logic","content":" match: system called once for the systemcontext =&gt; { features, system } match: module called for each modulecontext =&gt; { features, system, module } match: interface called once per interface in all modulescontext =&gt; { features, system, module, interface } match: struct called once per struct in all modulescontext =&gt; { features, system, module, struct } match: enum called once per enum in all modulescontext =&gt; { features, system, module, enum }  ","version":"Next","tagName":"h3"},{"title":"Documents​","type":1,"pageTitle":"Rules Document","url":"/docs/advanced/maker/rules#documents","content":" A document defines the source template and the target where to write the document.  The document define the source, target and some additional flags for writing.  source: source path inside the templates directory.target: target template string inside the output directory.force: if true, the document will be forced to be overwritten when re-generated.raw: if true, document will be just copied and not treated as template. Raw if off by default. ","version":"Next","tagName":"h2"},{"title":"Symbol Reference","type":0,"sectionRef":"#","url":"/docs/advanced/maker/symbols","content":"","keywords":"","version":"Next"},{"title":"Named Element​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#named-element","content":" Named element is the base element for all symbols. It contains the following properties:  Name: string name of the element Description: string test to describe the element Meta: object free form data, evaluated by the technology template Kind: string one of [module, interface, struct, enum, property, operation, signal]  ","version":"Next","tagName":"h2"},{"title":"Typed Element​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#typed-element","content":" Typed element is a named element with additional properties for typing  Type type information one of [bool, int, float, string] or reference to interface, struct, enum Array: true if the type is an arrayIsPrimitive: primitive type type is one of [bool, int, float, string] IsSymbol: is reference to type type is one of struct, enum, interface IsPrimitiveArray: array with items of primitive typeIsSymbolArray: array with item of reference to typeIsArray: true if the type is an array  ","version":"Next","tagName":"h2"},{"title":"Module​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#module","content":" The module is an element with additional version and an information object. Additional it contains a list of interfaces, structures and enumerations  All information from the element plus  Version: stringInfo: information objectInterfaces: array of interface elementsStructs: array of struct elementsEnums: array of enum elements  ","version":"Next","tagName":"h2"},{"title":"Information​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#information","content":" The information object allows customers to provide additional information about the API.  Title: stringDescription: stringTermsOfService: stringContact: is an object consisting of name, url and emailLicense: is an object containing of name and url  ","version":"Next","tagName":"h3"},{"title":"Interface​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#interface","content":" The interface is an container element for properties, operations and signals.  All information from the element plus  Properties: array of property elementsOperations: array of operation elementsSignals: array of signal elements  ","version":"Next","tagName":"h2"},{"title":"Property​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#property","content":" Property is a typed element.  All information from the typed element.  ","version":"Next","tagName":"h3"},{"title":"Operation​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#operation","content":" Operation is a named element with an additional list of typed parameters. The return element defines the return type.  All information from the typed element plus  Params: array of typed elementsReturn: type information  ","version":"Next","tagName":"h3"},{"title":"Signal​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#signal","content":" Signal is a typed element and has the same signature as operation, besides the return type information is ignored.  All information from the typed element plus  Params: array of typed elements  ","version":"Next","tagName":"h3"},{"title":"Structure​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#structure","content":" Structure is an element and act as a container for fields.  All information from the element, plus  Fields: array of typed elements  ","version":"Next","tagName":"h2"},{"title":"Field​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#field","content":" Field is a typed element.  All information from the typed element  ","version":"Next","tagName":"h3"},{"title":"Enumeration​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#enumeration","content":" Enumeration is an element and act as a container for members.  All information from the element, plus  Members: array of member  ","version":"Next","tagName":"h2"},{"title":"Member​","type":1,"pageTitle":"Symbol Reference","url":"/docs/advanced/maker/symbols#member","content":" Member is a element with an additional value.  All information from the named element, plus  Value: the value of the member ","version":"Next","tagName":"h3"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/maker/intro","content":"","keywords":"","version":"Next"},{"title":"Maker​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/maker/intro#maker","content":" A user which creates templates is called a maker. Normally is is possible to contribute to existing templates to enhance in an open discussion the quality for everyone. But often there is also a desire to solve a new problem or to create a project specific adaptation. In these cases it makes sense to fork a template or to create a new template.  templates allows you to solve all kind of API structured problems in a very easy way.  ","version":"Next","tagName":"h2"},{"title":"Creating a template​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/maker/intro#creating-a-template","content":" A template is a folder with a common structure consisting of a rules document, which controls the code generation process and the templates folder. The templates will be listed inside a rules document. Later a solution document will link the template with API modules for code generation.  Below is roughly the process to create and develop a template  Create a template folder with rules document and templates folderCreate an ApiGear Studio API project with a demo APIAdd a solution to the API project to link API modules with the templateEdit the template and re-generate the output  The templates are written using the go-template template language and each template should end with .tpl. ApiGear extends the template language by custom programming language specific filters to ease many complex tasks.  The Go-Template is used in several projects and is well documented. The ApiGear extensions are documented in the Filters section.  ","version":"Next","tagName":"h2"},{"title":"Your first template​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/maker/intro#your-first-template","content":" A typical template folder structure looks like this  first/ rules.yaml templates/welcome.txt.tpl   The rules document is a YAML document and lists all template file and how they shall be written inside the output folder. A simple rules document could look like this:  features: - name: default scopes: - match: system documents: - source: welcome.txt.tpl target: welcome.txt   The first level (here default) defines a feature. This can be enabled or disabled using the feature settings for the code generator. The next level (here system) defines to which symbol is shall be applied. A symbol is a defined location inside the API description.  Inside an API there exists the following symbols:  system: will be applied once for the root level systemmodule: will be applied for each module in the systeminterface: will be is applied for each interface inside the modulestruct: will be is applied for each struct inside the moduleenum: will be is applied for each enum inside the module  For each of these symbols inside the API description the target documents are written based on the source template.  You could think of the underlying logic of a rules document like this (using a python pseudo-code):  system = ... write_system_documents() for module in system.modules: write_module_documents() for interface in module.interfaces: write_interface_documents() for struct in module.structs: write_struct_documents() for enum in module.enums: write_enum_documents()   Here is a more elaborate example of a rules document:  # rules.yaml features: - name: default scopes: - match: system documents: - source: system.md.tpl target: system.md - match: module documents: - source: module.md.tpl target: {{.Module.Name}}.md - match: interface: documents: - source: interface.md.tpl target: {{.Interface.Name}}.md - match: struct documents: - source: struct.md.tpl target: {{.Struct.Name}}.md - match: enum documents: - source: enum.md.tpl target: {{.Enum.Name}}.md - name: summary scopes: - match: system documents: - source: summary.md.tpl target: summary.md   The {{ }} are a template expression. For example {{.Module.Name}} will be replaced with the content of module name. This allows you to write exactly these document names you require.  Additional to the template tags, the template engine also support filters. A filter is a function which takes a object and return a string. For example {{ lower .Module.Name }} or {{ .Module.Name | lower }} will lower case the module name. There are more filters in the in our filters documentation. ","version":"Next","tagName":"h2"},{"title":"Template Primer","type":0,"sectionRef":"#","url":"/docs/advanced/maker/template","content":"","keywords":"","version":"Next"},{"title":"Basic Syntax​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#basic-syntax","content":" The template syntax writes the text as is to the target file. Actions inside the text allow to control the output. A action is a text inside {{ and }}. The action can be a variable, a function or a control structure.  To access variables you can use the current scope .. All variables are title case. For example to access the name of the current module you can use the following template:  {{ .Module.Name }}   ","version":"Next","tagName":"h2"},{"title":"Loops​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#loops","content":" To iterate over a list you can use the range keyword. For example to iterate over all interfaces in the current module:  {{ range .Module.Interfaces }} {{ .Name }} {{ end }}   See how the current context changes inside the range loop.  A loop can also be empty and the else keyword can be used to define the empty case. For example to iterate over all interfaces in the current module:  {{ range .Module.Interfaces }} {{ .Name }} {{ else }} No interfaces found {{ end }}   To use the index and current element you can  {{ range $index, $element := .Module.Interfaces }} {{ $index }}: {{ $element.Name }} {{ end }}   Index is a zero-based iterator and element is the current element in the loop.  tip To join lists with commas you can use the loop index. {{ range $i, $e := .Module.Interfaces }} {{ if $i}},{{ end }}{{ .Name }} {{ end }} A comma will be printed when $i is not zero.  ","version":"Next","tagName":"h2"},{"title":"Assignments​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#assignments","content":" To define new variable you can assign a value to a variable. For example to assign the name of the current module to a variable:  {{ $name := .Module.Name }}   tip This allows you to define a set of variables at the beginning of the document and used them throughout. For example a class name for the current interface: {{ $class := Camel .Name }}   ","version":"Next","tagName":"h2"},{"title":"Conditionals​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#conditionals","content":" You can use an if-end or if-else-end construct to control the output. For example to only output the name of the current interface if it is not empty:  {{ if .Name }} {{ .Name }} {{ end }}   or to output a default value if the name is empty:  {{ if .Name }} {{ .Name }} {{ else }} {{ .Module.Name }} {{ end }}   ","version":"Next","tagName":"h2"},{"title":"White Space​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#white-space","content":" The template language allows to control the white space. For example to remove the white space before the output:  {{- if .Name }} {{ .Name }} {{- end }}   or to remove the white space after the output:  {{ if .Name -}} {{ .Name }} {{ end }}   ","version":"Next","tagName":"h2"},{"title":"String Formatting​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#string-formatting","content":" You can use the printf function to format strings. For example to prefix an interface name with I:  {{ printf &quot;I%s&quot; .Name }}   or to merge two strings, where each string is camel cased.  {{ printf &quot;%s%s&quot; (Camel .Interface.Name) (Camel .Name) }}   The printf syntax is described in the Go Printf Formatting.  ","version":"Next","tagName":"h2"},{"title":"Debugging Templates​","type":1,"pageTitle":"Template Primer","url":"/docs/advanced/maker/template#debugging-templates","content":" Sometimes it is useful to see the current context of the template. You can use the printf function to print the current context:  {{ printf &quot;%#v&quot; . }}  ","version":"Next","tagName":"h2"},{"title":"Filter Reference","type":0,"sectionRef":"#","url":"/docs/advanced/maker/filters","content":"","keywords":"","version":"Next"},{"title":"Template Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#template-filters","content":" String filters are used inside templates to transform text in different formats.  A typical usage would use the filter name followed by a string reference to the value to be transformed. For example:  {{ snake .Module.Name }}   Where . is the current context and .Module is the module object from the current context and .Name is the name property of the module object. The context can change for example inside a range loop.  {{ range .Module.Interfaces }} {{ snake .Name }} {{ end }}   Where the current context if the interface object inside the range loop.  ","version":"Next","tagName":"h2"},{"title":"String Filter​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#string-filter","content":" The list of the common string filters are listed here  ","version":"Next","tagName":"h2"},{"title":"snake, Snake, SNAKE​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#snake-snake-snake","content":" Converts a string to snake case - (lower, title, upper) case with underscores   {{snake &quot;org.demo&quot;}} =&gt; org_demo {{Snake &quot;org.demo&quot;}} =&gt; Org_Demo {{SNAKE &quot;org.demo&quot;}} =&gt; ORG_DEMO   ","version":"Next","tagName":"h3"},{"title":"camel, Camel, CAMEL​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#camel-camel-camel","content":" Converts a string to camel case - (lower, title, upper) case with first letter lower case  {{camel &quot;org.demo&quot;}} =&gt; orgDemo {{Camel &quot;org.demo&quot;}} =&gt; OrgDemo {{CAMEL &quot;org.demo&quot;}} =&gt; ORGDEMO   ","version":"Next","tagName":"h3"},{"title":"dot, Dot, DOT​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#dot-dot-dot","content":" Converts a string to dot case - (lower, title, upper) case with dots  {{dot &quot;org.demo&quot;}} =&gt; org.demo {{Dot &quot;org.demo&quot;}} =&gt; Org.Demo {{DOT &quot;org.demo&quot;}} =&gt; ORG.DEMO   ","version":"Next","tagName":"h3"},{"title":"kebap, Kebap, KEBAP​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#kebap-kebap-kebap","content":" Converts a string to kebap case - (lower, title, upper) case with dashes  {{kebap &quot;org.demo&quot;}} =&gt; org-demo {{Kebap &quot;org.demo&quot;}} =&gt; Org-Demo {{KEBAP &quot;org.demo&quot;}} =&gt; ORG-DEMO   ","version":"Next","tagName":"h3"},{"title":"path, Path, PATH​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#path-path-path","content":" Converts a string to path case - (lower, title, upper) case with slashes  {{path &quot;org.demo&quot;}} =&gt; org/demo {{Path &quot;org.demo&quot;}} =&gt; Org/Demo {{PATH &quot;org.demo&quot;}} =&gt; ORG/DEMO   ","version":"Next","tagName":"h3"},{"title":"lower​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#lower","content":" Converts a string to lower case  {{lower &quot;org.demo&quot;}} =&gt; org.demo   ","version":"Next","tagName":"h3"},{"title":"upper*​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#upper","content":" Converts a string to upper case  {{upper &quot;org.demo&quot;}} =&gt; ORG.DEMO   ","version":"Next","tagName":"h3"},{"title":"upperFirst​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#upperfirst","content":" Converts the first letter of a string to upper case  {{upper1 &quot;org.demo&quot;}} =&gt; Org.demo   ","version":"Next","tagName":"h3"},{"title":"lowerFirst​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#lowerfirst","content":" Converts the first letter of a string to lower case  {{lower1 &quot;org.demo&quot;}} =&gt; org.demo   ","version":"Next","tagName":"h3"},{"title":"first, First, FIRST​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#first-first-first","content":" Returns the first character of a string as lower, unchanged, upper case  {{first &quot;org.demo&quot;}} =&gt; o {{First &quot;org.demo&quot;}} =&gt; o {{FIRST &quot;org.demo&quot;}} =&gt; O   ","version":"Next","tagName":"h3"},{"title":"join​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#join","content":" joins a list of strings with a separator  {{join .Module.Interfaces &quot;, &quot;}} =&gt; org.demo.Interface1, org.demo.Interface2   ","version":"Next","tagName":"h3"},{"title":"trimPrefix​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#trimprefix","content":" Trims a prefix from a string  {{trimPrefix &quot;org.demo&quot; &quot;org.&quot;}} =&gt; demo   ","version":"Next","tagName":"h3"},{"title":"trimSuffix​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#trimsuffix","content":" Trims a suffix from a string  {{trimSuffix &quot;org.demo&quot; &quot;.demo&quot;}} =&gt; org   ","version":"Next","tagName":"h3"},{"title":"replace​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#replace","content":" Replaces a string with another string  {{replace &quot;org.demo&quot; &quot;org&quot; &quot;com&quot;}} =&gt; com.demo   ","version":"Next","tagName":"h3"},{"title":"int2word, Int2Word, INT2WORD​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#int2word-int2word-int2word","content":" Converts an integer to words (lower, title and upper case)  {{int2word 1}} =&gt; one {{Int2Word 1}} =&gt; One {{INT2WORD 1}} =&gt; ONE   ","version":"Next","tagName":"h3"},{"title":"plural​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#plural","content":" pluralizes a string  {{plural &quot;org.demo&quot;}} =&gt; org.demos   ","version":"Next","tagName":"h3"},{"title":"nl​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#nl","content":" prints a new line  {{nl}}   ","version":"Next","tagName":"h3"},{"title":"version​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#version","content":" extracts major, minor, build version from a version string  {{$v := version &quot;1.2.3&quot;}} {{$v}} =&gt; 1.2.3 {{$v.Major}} =&gt; 1 {{$v.Minor}} =&gt; 2 {{$v.Build}} =&gt; 3   ","version":"Next","tagName":"h3"},{"title":"Language Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#language-filters","content":" All programming languages share a common set of filters which then are adapted to the specifics of the language. These are return, param, params, vars, names and the default filter.  For example for the C++ programming language you would use the return and params filter named cpp14Return and cpp14Params during operation declaration.  A typical usage could look like this:  {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}({{ cppParams &quot;&quot; .Params }}); {{ end }}   Here the cppReturn and cppParams are the language specific filters for the C++ programming language. The &quot;&quot; is the a prefix applied to the return type and the parameters. This is used to add a namespace to the return type and the parameters. All language specific filters have the same signature.  tip We might offer a &quot;2&quot; version of a language filter in the future (e.g. cppReturn and cppReturn2) where the second version will support the prefix syntax.  These are the common filters for all languages  ","version":"Next","tagName":"h2"},{"title":"{lang}Return​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langreturn","content":" Takes and typed element and returns the type declaration of the type  {{ range .Module.Interfaces }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}({{ cppParams &quot;&quot; .Params }}); {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Param​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langparam","content":" Takes a typed element and returns the function parameter declaration  {{ range .Module.Interfaces }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}( {{ range $i, $p := .Params }} {{ if $i }}, {{ end }} {{ cppParam &quot;&quot; $p }} {{ end }}); {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Params​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langparams","content":" Takes an operation and return the lists of function parameters  {{ range .Module.Interfaces }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{ camel .Name }}({{ cppParams &quot;&quot; .Params }}); {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Default​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langdefault","content":" Takes a typed element and returns default value  {{ range .Module.Interfaces }} {{ $class := .Name }} {{ range .Operations }} {{ cppReturn &quot;&quot; .Return }} {{$class}}::{{ camel .Name }}({{ cppParams &quot;&quot; .Params }}) { return {{ cppDefault &quot;&quot; .Return }}; } {{ end }} {{ end }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Vars​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langvars","content":" Takes a list of types and creates variable names for them  {{ cppVars &quot;&quot; .Properties }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Var​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langvar","content":" Takes a typed element and creates a variable name for it  {{ cppVar &quot;&quot; .Property }}   ","version":"Next","tagName":"h3"},{"title":"{lang}Type​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#langtype","content":" Takes a typed element and returns the type declaration of the type  {{ cppType &quot;&quot; .Property }}   ","version":"Next","tagName":"h3"},{"title":"C++14 Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#c14-filters","content":" cppReturn: takes a typed element and returns the type declaration of the typecppParam: takes a typed element and returns the function parameter declarationcppParams: takes an operation and return the lists of function parameterscppDefault: takes a typed element and returns default valuecppVars: takes a list of types and creates variable names for themcppVar: takes a typed element and creates a variable name for itcppType: takes a typed element and returns the type declaration of the typecppConstType: takes a typed element and returns the type declaration of the type with const qualifiercppNs: takes a symbol and returns the namespace declarationcppNsOpen: takes a symbol and returns the namespace openingcppNsClose: takes a symbol and returns the namespace closingcppGpl: takes a symbol and returns the GPL license header  ","version":"Next","tagName":"h2"},{"title":"Go Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#go-filters","content":" goReturn: takes a typed element and returns the type declaration of the typegoParam: takes a typed element and returns the function parameter declarationgoParams: takes an operation and return the lists of function parametersgoDefault: takes a typed element and returns default valuegoVars: takes a list of types and creates variable names for themgoVar: takes a typed element and creates a variable name for itgoType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"TypeScript Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#typescript-filters","content":" tsReturn: takes a typed element and returns the type declaration of the typetsParam: takes a typed element and returns the function parameter declarationtsParams: takes an operation and return the lists of function parameterstsDefault: takes a typed element and returns default valuetsVars: takes a list of types and creates variable names for themtsVar: takes a typed element and creates a variable name for ittsType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"QtC++ Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#qtc-filters","content":" qtReturn: takes a typed element and returns the type declaration of the typeqtParam: takes a typed element and returns the function parameter declarationqtParams: takes an operation and return the lists of function parametersqtDefault: takes a typed element and returns default valueqtVars: takes a list of types and creates variable names for themqtVar: takes a typed element and creates a variable name for itqtType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"Python Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#python-filters","content":" pyReturn: takes a typed element and returns the type declaration of the typepyParam: takes a typed element and returns the function parameter declarationpyParams: takes an operation and return the lists of function parameterspyDefault: takes a typed element and returns default valuepyVars: takes a list of types and creates variable names for thempyVar: takes a typed element and creates a variable name for itpyType: takes a typed element and returns the type declaration of the type  ","version":"Next","tagName":"h2"},{"title":"Unreal Engine Filters​","type":1,"pageTitle":"Filter Reference","url":"/docs/advanced/maker/filters#unreal-engine-filters","content":" ueReturn: takes a typed element and returns the type declaration of the typeueParam: takes a typed element and returns the function parameter declarationueParams: takes an operation and return the lists of function parametersueDefault: takes a typed element and returns default valueueVars: takes a list of types and creates variable names for themueVar: takes a typed element and creates a variable name for itueType: takes a typed element and returns the type declaration of the typeueConstType: takes a typed element and returns the type declaration of the type with const qualifier ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/monitor/intro","content":"","keywords":"","version":"Next"},{"title":"What is API Monitoring?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#what-is-api-monitoring","content":" API Monitoring is a feature that allows you to monitor the usage of your API. It allows you to detect anomalies and to see how your API is used during runtime. This is especially useful during development and testing.  ","version":"Next","tagName":"h2"},{"title":"How does it work?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#how-does-it-work","content":" API Monitoring is a protocol that is implemented by the ApiGear templates. It allows clients to send API usage information to an API Monitoring Service. For development a server is embedded into your local ApiGear Studio / CLI application. This allows developers to see in real-time how the API is used and detect any anomalies fast.  ","version":"Next","tagName":"h2"},{"title":"How to use it?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#how-to-use-it","content":" To use API Monitoring you need to use a template that supports it. Please check the documentation of the template you are using for more information.  When you generate your API SDK you can use the monitor feature to include the monitoring code into your API SDK. This will allow you to send API usage information to the monitoring server.  When your client application is running messages will be send to the monitoring server. You can then use the monitoring server to see the API usage information.  ","version":"Next","tagName":"h2"},{"title":"How to setup the monitoring server?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/monitor/intro#how-to-setup-the-monitoring-server","content":" The monitoring server is embedded into the ApiGear Studio / CLI application. You can find the monitoring server settings in the settings page of the ApiGear Studio.  note If your template supports tracing, please consult the individual template documentation._ ","version":"Next","tagName":"h2"},{"title":"Monitoring Protocol","type":0,"sectionRef":"#","url":"/docs/advanced/monitor/protocol","content":"","keywords":"","version":"Next"},{"title":"HTTP Tracing​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#http-tracing","content":" The http tracing endpoint can be looked up under ApiGear Studio settings page.  All HTTP traces work in batch mode. You need to send an array of traces to the server. The oldest trace should be the first element in the array. This should normally be the order you recieve the traces from a FIFO queue.  In case no ID was transferred we generate a running ID based on the current timestamp.  ","version":"Next","tagName":"h2"},{"title":"Tracing operation calls​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#tracing-operation-calls","content":" For an method call the message looks like this:  An API call occurs when the client calls an method. The uri is the module name, joined with the interface name. A URI fragment (#) is added for the interface methods.  { &quot;type&quot;: &quot;call&quot;, &quot;symbol&quot;: &quot;${module}.${interface}/${method}&quot;, &quot;data&quot;: &quot;${params}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Tracing property changes​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#tracing-property-changes","content":" A state change can be an partial update or a full update of all interface properties. The state is always an JSON object.  { &quot;type&quot;: &quot;state&quot;, &quot;symbol&quot;: &quot;${module}.${interface}&quot;, &quot;data&quot;: &quot;${state}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Reporting a signal notification​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#reporting-a-signal-notification","content":" For an interface signal the message looks like this  { &quot;type&quot;: &quot;signal&quot;, &quot;symbol&quot;: &quot;${module}.${interface}/${signal}&quot;, &quot;data&quot;: &quot;${params}&quot; }   ","version":"Next","tagName":"h3"},{"title":"Websocket Tracing​","type":1,"pageTitle":"Monitoring Protocol","url":"/docs/advanced/monitor/protocol#websocket-tracing","content":" Tracing over web sockets uses the JSON-RPC protocol. The protocol is mostly the same as the http protocol.  The JSON RPC method is called trace and uses the same endpoint as the simulation server for ApiGear Studio. Where in the HTTP trace protocol the source as part of the endpoint, in the websocket protocol it is part of the message.  Otherwise all parameters, especially also the type are the same.  The websocket tracing endpoint can be looked up under ApiGear Studio settings page.  { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;trace&quot;, &quot;params&quot;: { &quot;id&quot;: &quot;1000230240&quot;, &quot;source&quot;: &quot;local-device&quot;, &quot;type&quot;: &quot;call&quot;, &quot;symbol&quot;: &quot;count.Counter/increment&quot;, &quot;data&quot;: {} } }  ","version":"Next","tagName":"h2"},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/docs/advanced/maker/tutorial","content":"","keywords":"","version":"Next"},{"title":"Creating a template​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#creating-a-template","content":" In this project we will create a mytemplate template inside a myproject together some apis to test the template.  mkdir myproject &amp;&amp; cd myproject mkdir mytemplate &amp;&amp; cd mytemplate   First we create our toot project folder called myproject and inside out template folder called mytemplate. Insie the mytemplate folder we place a rules document (rules.yaml) and an templates folder for our template documents.  The folder structure will look like this.  myproject/ mytemplate/ rules.yaml templates/   The rules document defines which documents are written based on which API symbols, in our case we use the module scope, as we want to create one document per module. The source document is a tpl template document and the target document is a text document, where the target name can also be a template string.  # rules.yaml features: - name: default scopes: - match: module documents: - { source: module.ts.tpl, target: {{.Module.Name}}.ts }   The module.ts.tpl file inside the template/templates folder can be empty initially, we fill it up later.  Now our basic template project is ready, it's time to link it up with an ApiGear Studio API project.  myproject/ mytemplate/ rules.yaml templates/ module.ts.tpl   ","version":"Next","tagName":"h2"},{"title":"Create API Project​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#create-api-project","content":" Open ApiGear Studio and add an API project to the myproject folder. This will create an apigear folder to the project.  From within ApiGear Studio create an API module named demo which will act as our test API.  Copy our demo API into the API document.  # demo.module.yaml schema: &quot;apigear.module/1.0&quot; name: demo version: &quot;0.1&quot; interfaces: - name: Counter properties: - name: count type: int operations: - name: increment - name: decrement   The demo API now needs to be linked to the template rules document. This is done from within a solution document, which links API modules to templates.  Open ApiGear Studio and create a solution document also called demo, and the content should look like this.  # demo.solution.yaml schema: &quot;apigear.solution/1.0&quot; name: demo version: &quot;0.1&quot; layers: - name: demo output: ../output inputs: - demo.module.yaml template: ../mytemplate features: - default   This will first parse all defined modules (demo) and apply the given template to the modules. The documents will then be written relative to the given output directory.  Your project should look like this now:  myproject/ apigear/ demo.module.yaml demo.solution.yaml template/ rules.yaml templates/ module.ts.tpl   When you now run the solution it will create an empty output/demo.ts document inside the project directory.  Now we have a basic setup ready.  myproject/ apigear/ demo.module.yaml demo.solution.yaml template/ rules.yaml templates/ module.ts.tpl output/ demo.ts   ","version":"Next","tagName":"h2"},{"title":"Demo Goal​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#demo-goal","content":" Remember we want to create an interface for each interface inside an API module. For our demo API the resulting typescript shall look like this:  // demo.ts interface Counter { count: int; increment(): void; decrement(): void; }   This defines a standalone typescript interface to be usable in your applications.  The rules document already takes care that for each API module one typescript document is created, based on the module name. Now we need to fill in the content of the typescript code.  ","version":"Next","tagName":"h2"},{"title":"Typescript Template​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#typescript-template","content":" Inside our module.ts.liquid template document each interface in the module shall be an typescript interface. This can be accomplished with the for-loop from the liquidjs template engine.  {{ range .Module.Interfaces }} interface {{ .Name }} { } {{ end }}   After updating the module.ts.tpl with the above content, we can run the solution. This will rewrite the target document with the content of the typescript template.  interface Counter {}   ","version":"Next","tagName":"h2"},{"title":"Filling in the details​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#filling-in-the-details","content":" There are still the properties and operations missing from the source code. We can add them into the template using another for loop, which iterate over the properties and operations from the interface.  {{ range .Module.Interfaces }} interface {{ .Name }} { {{ range .Properties }} {{ .Name }}: {{ tsType . }}; {{ end }} {{ range .Operations }} {{ .Name }}(): {{ tsReturn .Return }}; {{ end }} } {{ end }}   This will already add the properties and some simple operations to the source code. After running the solution we will see the update source code.  // demo.ts interface Counter { count: int; increment(): void; decrement(): void; }   So great. Are we finished? The mindful reader already figured out that the operation parameters are missing. To demonstrate this we will add steps parameters to the increment and decrement operations.  We first update our API demo module (demo.module.yaml) adding parameters to the operations like this:  operations: - name: increment params: - name: step type: int - name: decrement params: - name: step type: int   If you would run the solution again you would no see a change as we currently not handle these parameters. We need to update the template document (module.ts.liquid) first to handle the parameters using the params filter.  {{ range .Operations }} {{ .Name }}({{ params .Params }}): {{ tsReturn .Return }}; {{ end }}   Now running the solution again will update the typescript source code to the final result:  // demo.ts interface Counter { count: int; increment(step: int): void; decrement(step: int): void; }   This shows how easy it is to create an own template solution for a supported technology.  ","version":"Next","tagName":"h2"},{"title":"Packaging​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#packaging","content":" Template packages are git repositories, which can be published to a git server. The template package can be referenced from a solution document using the git scheme.  apigear template install &lt;git-url&gt;   Or if the template is registered with the registry, it can be installed using the name.  apigear template install &lt;name&gt;   ","version":"Next","tagName":"h2"},{"title":"Next Steps​","type":1,"pageTitle":"Quick Start","url":"/docs/advanced/maker/tutorial#next-steps","content":" This simple demo shows the workflow of creating technology templates using ApiGear Studio.  ApiGear support several programming languages and technologies, such as Python, C++, TypeScript, Go and others and is able to create complex solutions for almost every application.  ApiGear comes with several advanced technology templates which provides solutions for the most common problems. In case the provides solutions do not fit your needs ApiGear is designed to allow quick adoptions of the underlying technology templates. ","version":"Next","tagName":"h2"},{"title":"Advanced Concepts","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/advanced","content":"","keywords":"","version":"Next"},{"title":"Document information​","type":1,"pageTitle":"Advanced Concepts","url":"/docs/advanced/objectapi/advanced#document-information","content":" The info section allows user to add information related to the current document.  info: license: &lt;license-identifier&gt;   ","version":"Next","tagName":"h2"},{"title":"Meta information​","type":1,"pageTitle":"Advanced Concepts","url":"/docs/advanced/objectapi/advanced#meta-information","content":" Sometimes it is required to add additional information, which is not part of the ObjectAPI specification. For this the meta tag can be used.  interfaces: - name: Tuner meta: singleton: true config: { port: 1024 }   As the information is not part of the specification the applied code generator must have an understanding of the data. For example a C++ code generator could create a singleton type from the interface declaration.  ","version":"Next","tagName":"h2"},{"title":"Compact Writing​","type":1,"pageTitle":"Advanced Concepts","url":"/docs/advanced/objectapi/advanced#compact-writing","content":" YAML allows a compact format for single line information. This allows us to shorten API definitions considerable. For example this API  structs: - name: Error fields: - name: message, type: string - name: code type: int   Can be written in a short format like this:  structs: - name: Error fields: - { name: message, type: string } - { name: code, type: int }  ","version":"Next","tagName":"h2"},{"title":"API Foundation","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/core","content":"","keywords":"","version":"Next"},{"title":"Format​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#format","content":" ObjectAPI is described as an open specification format using JSON Schema. Every ObjectAPI document must conform to this JSON schema definition.  tip While the the API is described in JSON, other formats like YAML can be used as input formats and are automatically converted to JSON by the ObjectAPI tooling.  Unless otherwise noted all file names in this specification are case sensitive.  ","version":"Next","tagName":"h2"},{"title":"Managing Documents​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#managing-documents","content":" The ObjectAPI documents are simple files on the file system. Several files can be processed together and form a system. It is convention that the file name matches the module name.  *.module.yaml | *.module.json - ObjectAPI document  Other files can be added which contain meta information for the API modules. They allow to inject additional information which is not relevant or available during API definitions.  *.module.meta.yaml | *.module.meta.json - ObjectAPI meta information injected into the relevant APIs.  So if a module is name org.example the ObjectAPI document should be called org.example.module.yaml  tip Outside of the ObjectAPI specification a solution document format is described which binds several modules together and links them to a code template for code generation.  ","version":"Next","tagName":"h2"},{"title":"Data Types​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#data-types","content":" In the ObjectAPI specification data types are used in many locations. State, Method return types and parameters, signal parameters or structures.  Data fields are added at the same level to describe the data name and type. For example for the interface properties, these are:  properties: - name: count type: int   The general types available to ObjectAPI are:  Primitive Types: bool, int, int32, int64, float, float32, float64, stringContainer Types: arraysComplex Types : structures, enumerations  ","version":"Next","tagName":"h2"},{"title":"Primitives​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#primitives","content":" Data types can be re-presented in different forms in different programming languages. They all need to be convertible to JSON data types on request.  bool - A simple boolean value (true or false)int, int32, int64 - A signed integer valuefloat, float32, float64 - A floating point valuestring - A string value  ","version":"Next","tagName":"h2"},{"title":"Arrays​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#arrays","content":" An array is an index based list of primitive or complex data types. Further nesting of containers are not supported but can be achieved using structs as array items. A data type is converted into a container by setting the type to array and specifying the containing type in the items key.  For example an integer array can be noted like this:  properties: - name: names type: string array: true   If an array does contain a symbol as containing type, then the symbol name can be used in the items key.  properties: - name: messages type: Message array: true   Primitive types are always start with a lower case character and symbols always with an upper case character.  tip The code templates will change the casing based on the target language preferences.  ","version":"Next","tagName":"h2"},{"title":"Complex Types​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#complex-types","content":" A symbol is a named element inside a module. This can be either an interface, struct or enum/flag symbol.  structs: - name: Message   Inside the same module the type can be referenced by the name of the symbol using a ref. This holds true for all symbols.  properties: - name: msg1 type: Message - name: msg2 type: Message array: true   Outside the module, the module itself needs to be imported and the type needs to be used with its fully qualified name  imports: - org.example interfaces: - name: Interface1 properties: - name: msg1 type: org.example.Message   org.example.Message - external symbol  Note: Not every language profile does support importing.  ","version":"Next","tagName":"h2"},{"title":"Rich Text Formatting​","type":1,"pageTitle":"API Foundation","url":"/docs/advanced/objectapi/core#rich-text-formatting","content":" Throughout the specification description support the markdown syntax. ","version":"Next","tagName":"h2"},{"title":"API Examples","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/examples","content":"","keywords":"","version":"Next"},{"title":"Counter​","type":1,"pageTitle":"API Examples","url":"/docs/advanced/objectapi/examples#counter","content":" The typical counter example to increment and decrement a count value.  schema: apigear.module/1.0 name: org.example version: &quot;1.0&quot; info: title: &quot;Counter API&quot; description: A counter module develope interfaces: - name: Counter description: Counter interface to count up and down properties: - name: count type: int operations: - name: increment - name: decrement   ","version":"Next","tagName":"h2"},{"title":"Radio Tuner​","type":1,"pageTitle":"API Examples","url":"/docs/advanced/objectapi/examples#radio-tuner","content":" A radio tuner with a current station and a station list. It can operate on different wavebands.  schema: apigear.module/1.0 module: entertainment.tuner version: 1.0 interfaces: - name: Tuner description: A tuner service to manages tuner stations properties: - name: currentStation type: Station description: current selected station - name: stationList type: Station[] description: list of current available stations operations: - name: nextStation description: sets current station to next station from list - name: previousStation description: sets current station to previous station from list - name: updateCurrentStation description: update current station params: - name: stationId - type: id structs: - name: Station fields: - name: stationId type: id description: station id - name: name type: string description: station name - name: modified type: string format: date-time description: station last time modified enums: - name: State description: State for tuner interface members: - name: None description: tuner not initialized - name: Loading description: tuner is loading - name: Ready description: tuner is ready and operational - name: Error description: tuner received an error - name: Waveband members: - name: FM description: FM waveband - name: AM description: AM waveband   ","version":"Next","tagName":"h2"},{"title":"Weather Station​","type":1,"pageTitle":"API Examples","url":"/docs/advanced/objectapi/examples#weather-station","content":" The weather station uses a more compact YAML format to display the current temperature.  schema: apigear.module/1.0 module: sensors.weatherstation version: 2.5 interfaces: - name: WeatherStation - properties: - { name: temperature, type: float } - { name: lastError, type: Error } - operations: - { name: reset } - signals: - name: error params: - { name: error, type: Error } structs: - name: Error fields: - name: msg type: string  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/intro","content":"","keywords":"","version":"Next"},{"title":"Introduction​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#introduction-1","content":" The ObjectAPI specification is a project used to describe and document object oriented APIs across languages and technologies.  The ObjectAPI specification defines a set of files required to describe such an API. These files can then be used to create utilities, such as documentation, integration and/or testing tools.  The ObjectAPI Specification is often used to describe the interface between software modules or inter-process communication (IPC) in distributed systems built using a object oriented programming API. The ObjectAPI recommends to split APIs into smaller modules with loose coupling.  The documents describe an API module and its interfaces and data structures.  ","version":"Next","tagName":"h2"},{"title":"Revision History​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#revision-history","content":" ","version":"Next","tagName":"h2"},{"title":"Version 0.2​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#version-02","content":" Initial ObjectAPI specificationSimplified the ObjectAPI document format  ","version":"Next","tagName":"h3"},{"title":"Definitions​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectapi/intro#definitions","content":" System : A system is a collection of modules, which describe a coherent set of APIs on the same layer.Module : A module describes a name spaced collection of API symbols, such as interfaces, structures, enumerations. There exists one module per file.Interface: A interface is a description of a named object with properties, operations and signals.Structure: A structure is a data type with fields describing the data structure. A structure has no operations or signals.Enumeration: An enumeration is a enumerated integer type with a set of named values. ","version":"Next","tagName":"h2"},{"title":"HTTP Mapping","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/mapping_http","content":"","keywords":"","version":"Next"},{"title":"ObjectAPI Mapping​","type":1,"pageTitle":"HTTP Mapping","url":"/docs/advanced/objectapi/mapping_http#objectapi-mapping","content":" module: Is a namespace and does not map directly.interface: /${module}/${interface} GET fetches the state of the interfacePOST sets the interface statePATCH partial update of the interface state operation: /${module}/${interface}/${operation} POST invokes the operation and returns the response  Structure are mapped like the normal JSON mapping of ObjectAPI data types. Same applies to enumerations. ","version":"Next","tagName":"h2"},{"title":"Use Cases","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/cases","content":"","keywords":"","version":"Next"},{"title":"Services​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#services","content":" When designing embedded platforms, it is often necessary to provide a state full design. The state is inherent from the device (e.g. temperature, location, current radio station). These states are often used by multiple applications. The applications are often not aware of each other and the state is not synchronized. This leads to a lot of duplicated code and a lot of complexity.  The protocol allows to share state between applications. ANd the state is automatically synced across applications and platforms. The applications can be written in different languages and can be running on different platforms. The protocol is designed to be used with the ObjectAPI specification. This allows to define a common API surface for the applications.  Protocol Features Used:  Property: read/write/notifyOperations: request/responseSignals: notify  ","version":"Next","tagName":"h2"},{"title":"Sensors​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#sensors","content":" A sensor can just use the property aspects of the protocol. The sensor can send property changes to the application. The application can then use the property changes to update the UI. For this the sensor does have to be linked to the remote object.  Protocol Features Used:  Property: write  ","version":"Next","tagName":"h2"},{"title":"Actuators​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#actuators","content":" An actuator can just use the property aspects of the protocol. The application can send property changes to the actuator. The actuator can then use the property changes to update the state of the actuator. For this the actuator has to be linked to the remote object to receive changes.  Protocol Features Used:  Property: notify  ","version":"Next","tagName":"h2"},{"title":"Remote Procedure Calls​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#remote-procedure-calls","content":" The protocol can be used to implement remote procedure calls. The protocol is designed to be used with the ObjectAPI specification. This allows to define a common API surface for the applications. The protocol can be used to implement a remote procedure call. The request is send to the service and the service replies with the result.  Additional the service can notify the client about events using the signal aspect of the protocol.  Protocol Features Used:  Operations: request/response  ","version":"Next","tagName":"h2"},{"title":"Highly Interactive Services​","type":1,"pageTitle":"Use Cases","url":"/docs/advanced/objectlink/cases#highly-interactive-services","content":" The protocol can be used to implement highly interactive services. For example for a whiteboard application the protocol can dynamically update the UI about the current location of the pen and it's state. Actions can be expressed as operations using the request/reply aspect of the protocol. The signals can be used to send a constant stream of events to the client.  Protocol Features Used:  Property: read/write/notifyOperations: request/responseSignals: notify ","version":"Next","tagName":"h2"},{"title":"Protocol Mappings","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/mapping","content":"","keywords":"","version":"Next"},{"title":"API Types​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#api-types","content":" There exists currently several API types, like REST, Message Based or RPC. ObjectAPI supports a mixture of these.  ","version":"Next","tagName":"h2"},{"title":"REST based APIs​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#rest-based-apis","content":" REST API is about browsing data but the underlying nature of the protocol is HTTP. HTTP is a request/response protocol and as such is architecture wise next to RPC. REST itself defines an architectural style on top of HTTP.  For example to increment a value this logic would be in REST like this.    We first fetch the counter state, than increment the count value and push back the result. The logic is on the client side and the service mostly manages data.  A typical API would look like this:  const client = new HttpClient(); const data = await client.get(&quot;/counter/$id&quot;); data.count += 1; await client.put(&quot;/counter/$id&quot;);   Often these kind of APIs makes it hard in complex logic driven services to validate operations and data.  ","version":"Next","tagName":"h3"},{"title":"Message based APIs​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#message-based-apis","content":" Message based APIs are typically realized using a message broker. The broker is responsible to ensure all messages are delivered to the subscribed or registered peers.    First we would subscribe to and interface state changes. Then we would publish the increment signal and wait for changes on the interface state. The changes are announces by the service via the broker.  A typical message based client would look like this:  const client = new MessageClient(); client.subscribe(&quot;/counter/$id&quot;); client.on(&quot;/counter/$id&quot;, (v) =&gt; { console.log(v); }); client.publish(&quot;/counter/$id/increment&quot;);   ","version":"Next","tagName":"h3"},{"title":"Object based APIs​","type":1,"pageTitle":"Protocol Mappings","url":"/docs/advanced/objectapi/mapping#object-based-apis","content":" Object based APIs focus on the developer API and take care of the internal mapping to the different protocol types. Interface properties will be typically automatically synced and signals will allow service side notifications to the clients.    The API for this would look like this.  const client = new CounterClient(); client.on((s) =&gt; { console.log(s.count); }); await client.increment();   First we register a callback when the interface state changes. Then we call the operation, as we defined an object API the API feels and works as developers would expect this.  This makes it much nicer and easier to use the API inside your application. The The API patterns is also extended to the service side, where service calls end into an API which looks very mich like the defined ObjectAPI. ","version":"Next","tagName":"h3"},{"title":"ObjectAPI IDL","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/idl","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#interfaces","content":" An interface defines a set of properties, operations and signals.  interface name { `prop-name` : type // property `method-name` ( params ): `type` // operation signal `signal-name` ( params ) // signal }   A type can be either a primitive type or a complex type. A complex type can be a structure, enumeration or another interface.  A primitive type can be one of the following:  bool : boolean valueint, int32, int64 : integer valuefloat, float32, float64 : floating point valuestring : string value  A complex type can be one of the following:  name of an interfacename of an enumerationname of a structure  To define arrays of a type just append the [] to the type.  struct Struct1 {} interface Demo { propString: string propStringArray: string[] propStruct: Struct1 }   tip Currently we do not support importing other modules. This is planned for a future version.  ","version":"Next","tagName":"h2"},{"title":"Structures​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#structures","content":" A data structure is a message which can be used to send complex information between objects. A structure is defined as follows:  struct name { fieldName : type }   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#enumerations","content":" An enumeration is a set of named values. An enumeration is defined as follows:  enum Enum1 { Value1 = 0 Value2 = 1 Value3 = 2 }   A value can also be a hex number in the format of 0x2. If there is no value specified the next value is used.  ","version":"Next","tagName":"h2"},{"title":"Example​","type":1,"pageTitle":"ObjectAPI IDL","url":"/docs/advanced/objectapi/idl#example","content":" Here is a complete example:  module demo 1.0 interface Radio { // frequency is the current frequency in MHz frequency: float // stations is a list of stations stations: Station[] // if enabled automatically tunes to the next station autoTune: bool // scan for stations scan() // tune to a specific frequency tuneFrequency(float frequency) // tune to a specific station tuneStation(stationId: int) // signal emitted when a new station is found signal stationFound(stationId: int) } struct Station { // id is the station id id: int // name of the station name: string // short name of the station shortName: string // frequency in MHz frequency: float // artwork url artwork: string // category of the content category: Category } enum Category { News = 0 Music = 1 Talk = 2 }   Our ApiGear tooling can create code in different languages. For example in C++ this would look like (simplified):  class Radio { public: // scan for stations void scan(); // tune to a specific frequency void tuneFrequency(float frequency); // tune to a specific station void tuneStation(int stationId); // signal emitted when a new station is found void onStationFound(function&lt;void(int stationId)&gt; callback); public: // frequency is the current frequency in MHz float frequency; // stations is a list of stations std::vector&lt;Station&gt; stations; // if enabled automatically tunes to the next station bool autoTune; }; struct Station { // id is the station id int id; // name of the station std::string name; // short name of the station std::string shortName; // frequency in MHz float frequency; // artwork url std::string artwork; // category of the content Category category; };  ","version":"Next","tagName":"h2"},{"title":"Error Messages","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/errors","content":"","keywords":"","version":"Next"},{"title":"Error Codes​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#error-codes","content":" Error codes are string messages starting with olink.error. followed by a short description of the error. The following error codes are defined:  olink.error.invalid_message: the message is not a valid JSON arrayolink.error.invalid_message_type: the message type is not a valid integerolink.error.no_such_module: the module does not existolink.error.no_such_object: the object does not existolink.error.no_such_property: the property does not existolink.error.no_such_operation: the operation does not exist  tip Currently it is not possible to add details to the error message. This will be added in a future version.  ","version":"Next","tagName":"h2"},{"title":"Invalid Message​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#invalid-message","content":" The error message is send if the client sends an invalid message.  [ ERROR, 0, 0, &quot;olink.error.invalid_message&quot; ]   ","version":"Next","tagName":"h2"},{"title":"Invalid Message Type​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#invalid-message-type","content":" The error message is send if the client sends an invalid message type.  [ ERROR, 0, 0, &quot;olink.error.invalid_message_type&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Module​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-module","content":" The error message is send if the client tries to link to a non existing module.  [ ERROR, LINK, 0, &quot;olink.error.no_such.module&quot; ]   This error can also be send during an unlink operation if the module is not linked.  [ ERROR, UNLINK, 0, &quot;olink.error.no_such.module&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Object​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-object","content":" The error message is send if the client tries to link to a non existing object.  [ ERROR, LINK, 0, &quot;olink.error.no_such.object&quot; ]   This error can also be raised during an unlink operation if the object does not exists.  [ ERROR, UNLINK, 0, &quot;olink.error.no_such.object&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Property​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-property","content":" The error message is send if the client tries to set a property on a non existing property.  [ ERROR, SET_PROPERTY, 0, &quot;olink.error.no_such.property&quot; ]   ","version":"Next","tagName":"h2"},{"title":"No Such Operation​","type":1,"pageTitle":"Error Messages","url":"/docs/advanced/objectlink/errors#no-such-operation","content":" The error message is send if the client tries to invoke a non existing operation.  [ ERROR, INVOKE, 0, &quot;olink.error.no_such.operation&quot; ]  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/intro","content":"","keywords":"","version":"Next"},{"title":"JSON Notation​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectlink/intro#json-notation","content":" Throughout the protocol description, the JSON notation is used. All data types must be valid JSON data types.  For transport several protocols are supported, see list below:  JSONMsgPackCBOR  The client and server needs to know their transport and encoding in advance. There is no protocol negotiation designed. This allows us to keep the protocol simple.  ","version":"Next","tagName":"h2"},{"title":"Message Types​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectlink/intro#message-types","content":" Lifecycle --&gt; LINK - link the local object with a remote object&lt;-- INIT - initialized the local object with properties from the remote object--&gt; UNLINK - unlinks a local object from a remote object Properties --&gt; SET_PROPERTY - send a property change to a remote object&lt;-- PROPERTY_CHANGE - sends property changes to all linked client objects Methods --&gt; INVOKE - invoke a method on a remote object&lt;-- INVOKE_REPLY - reply of an remote invokation Signals &lt;-- SIGNAL - send remote events back to all linked client objects Errors &lt;-- ERROR - send an error back to the client with the msg type of the original message  ","version":"Next","tagName":"h2"},{"title":"Message Formats​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/objectlink/intro#message-formats","content":" Direction\tMessage\tValue\tFormat-&gt;\tLINK\t10\t[ MsgType, ObjectId ] &lt;-\tINIT\t11\t[ MsgType, ObjectId, Dict ] -&gt;\tUNLINK\t12\t[ MsgType, ObjectId ] -&gt;\tSET_PROPERTY\t20\t[ MsgType, PropertyId, Value ] &lt;-\tPROPERTY_CHANGE\t21\t[ MsgType, ObjectId, Value ] -&gt;\tINVOKE\t30\t[ MsgType, RequestID, MethodId, Args ] &lt;-\tINVOKE_REPLY\t31\t[ MsgType, RequestID, Value ] &lt;-\tSIGNAL\t40\t[ MsgType, SignalId, Args ] &lt;-\tERROR\t50\t[ MsgType, MsgType, RequestID, Error ]  MsgType: integer value of message typeObjectId: a string identifying the resource as module and object name (e.g. &quot;demo.Calc&quot;)Dict: A JSON dictionary, e.g. { &quot;count&quot;: 0}Args: A JSON array, e.g. [ 1, 2 ]PropertyId: A ObjectID with a property path (e.g. &quot;demo.Calc/count&quot;)Value: Any valid JSON value including JSON arrays or objectsMethodId: A ObjectID with a method path (e.g. &quot;demo.Calc/increment&quot;)RequestId: A unique integer value identifying the request during the connection. Typically a value incremented by one on each request and starting by 1 and then reset to 1 by max value.SignalId: A ObjectID with a signal path (e.g. &quot;demo.Calc/shutdown&quot;)Error: A string describing the error ","version":"Next","tagName":"h2"},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/lifecycle","content":"","keywords":"","version":"Next"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Lifecycle","url":"/docs/advanced/objectlink/lifecycle#sequence-diagram","content":" To link a local object to a remote object we need to send a link message.  ","version":"Next","tagName":"h2"},{"title":"Method Invokation","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/methods","content":"","keywords":"","version":"Next"},{"title":"ApiGear Object Model​","type":1,"pageTitle":"Method Invokation","url":"/docs/advanced/objectlink/methods#apigear-object-model","content":" To model methods in ApiGear you define an interface with operations.  name: org.demos interfaces: - name: Echo operations: - name: say params: - name: msg type: string type: string   The operations will be generated as methods of the object. This will look simplified like this.  // org.demos.js class Echo { async say(msg: string): string } const echo = new Echo() console.log(echo.say(&quot;hello&quot;)) $&gt; hello   ","version":"Next","tagName":"h2"},{"title":"Protocol Flow​","type":1,"pageTitle":"Method Invokation","url":"/docs/advanced/objectlink/methods#protocol-flow","content":" To invoke remote method an method name and the method arguments must be specified. The reply can only have on value, which can have any complexity.  The local object sends an INVOKE message to the remote object using a request id, the method name and method arguments.  --&gt; [ INVOKE, 1, &quot;org.demos.Echo/say&quot;, [&quot;echo&quot;]]   The remote object executes the method and returns the reply or an error message in case of failure.  &lt;-- [ INVOKE_REPLY, 1, &quot;echo&quot;]   ","version":"Next","tagName":"h2"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Method Invokation","url":"/docs/advanced/objectlink/methods#sequence-diagram","content":" After an object is linked remote methods can be called.  ","version":"Next","tagName":"h2"},{"title":"API Modules","type":0,"sectionRef":"#","url":"/docs/advanced/objectapi/modules","content":"","keywords":"","version":"Next"},{"title":"Module Namespaces​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#module-namespaces","content":" A module is a namespace for ObjectAPI symbols like interfaces, structures and enumerations. The module bundles these symbols together in one namespace.  A module is identified by its name and version. The module name should be typically lowercase and words separated by ., like a reverse URI notation org.example.  A module can have an additional info block to describe in more detailed the module information.  Typically a module consist of the apigear.interfaces version declaration, the module name and version, the list of interfaces, structures and signals.  The version number must be written as a string, otherwise it wil be converted to a numeric value (e.g. 1 for 1.0).  Only ObjectAPI, name, version are mandatory. The other identifiers are optional.  schema: apigear.module/1.0 name: org.example version: &quot;1.0&quot; interfaces: structs: enums:   ","version":"Next","tagName":"h2"},{"title":"Interfaces​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#interfaces","content":" An interface is the main instance to describe your software boundary using interface terms. The interface consist of state, operation and signals. The state is typically describe a a set of properties of the interface and operations modify the interface state. Signals notify the user of changes of the interface.  The interface itself is identified by its name inside a module.  schema: apigear.module/1.0 name: &quot;org.example&quot; version: &quot;1.0&quot; interfaces: - name: MyInterface   ","version":"Next","tagName":"h2"},{"title":"Object state​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#object-state","content":" Each property has a name and a type as also description and additional meta data.  # ... interfaces: - name: MyInterface properties: - name: value type: int   ","version":"Next","tagName":"h3"},{"title":"Operation​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#operation","content":" A operation defines the interaction with the interface. It is a collection of operations which can either manipulate the properties or return data.  Ideally you design your operations in a way that they can be divided into commands and queries. A command is an operation which does something on the interface and a query collects data from the interface and returns it to the user.  # ... interfaces: - name: MyInterface operations: - name: command description: A command does not have a return type - name: query type: string description: A query returns data   Operation can have parameter arguments  # ... interfaces: - name: MyInterface operations: - name: command params: - name: step type: int return: type: int   The arguments do parameterize the operation.  ","version":"Next","tagName":"h3"},{"title":"Signals​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#signals","content":" A signal allows the interface to notify the outside world about events happening, e.g. triggered by others. A signal is like an operation, but never defines a type.  # ... interfaces: - name: MyInterface signals: - name: error params: - name: code type: int   ","version":"Next","tagName":"h3"},{"title":"Data Structures​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#data-structures","content":" A structure represents a data structure which can be used for communication. The structure consists of a name and a set of data fields. Each field again has a name and a type information.  # ... structs: - name: Message fields: - name: msg type: string   A data structure does not contain any operations or signals. A data structure is typically used as a type for properties, operation parameters and others.  # ... interfaces: - name: MessageSender properties: - name: lastMessage type: Message operations: - name: send params: - name: msg type: Message   Data structure can be identified just be identified its name.  Data structures can be nested by using the type name of the nested type. In some programming languages care needs to be taken by the order of declaration.  ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"API Modules","url":"/docs/advanced/objectapi/modules#enumerations","content":" Enumerations and Flags are value types, which allow a user to use a defined number of choices to identify a value.  enums: - name: Status members: - name: None value: 0 - name: Loading value: 1 - name: Ready value: 2 - name: Error value: 3   The values are optional and when missing the value is counted incrementally from 0 on upwards.  enums: - name: Status members: - name: None - name: Loading - name: Ready - name: Error   An enumeration is also a symbol and can be used by its name to identify its type.  # ... interfaces: - name: MyInterface properties: - name: status type: Status # references the Status enumeration  ","version":"Next","tagName":"h2"},{"title":"Property Synchronization","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/properties","content":"","keywords":"","version":"Next"},{"title":"ApiGear Object Model​","type":1,"pageTitle":"Property Synchronization","url":"/docs/advanced/objectlink/properties#apigear-object-model","content":" In ApiGear properties are described as properties inside an interface.  name: org.demos interfaces: - name: Echo properties: - name: message type: string   The resulting simplified typescript code could look like this.  // org.demos.js class Echo { message: string = &quot;&quot; } const echo = new Echo() echo.message = &quot;foo&quot;   ","version":"Next","tagName":"h2"},{"title":"Protocol Flow​","type":1,"pageTitle":"Property Synchronization","url":"/docs/advanced/objectlink/properties#protocol-flow","content":" First the local object needs to be linked to a remote object.  --&gt; [ LINK, &quot;org.demos.Echo&quot;]   Now the local object receive initial property list, which is automatically send after the link message.  &lt;-- [ INIT, 'org.demos.Echo', { message: &quot;hello&quot; } ]   After the init message out local object is fully populated and all properties have valid values.  When a property is changed on the local object, for example from &quot;hello&quot; to &quot;foo&quot;, a SET_PROPERTY message is send.  --&gt; [ SET_PROPERTY, &quot;org.demos.Echo/message&quot;, &quot;foo&quot;]   The remote object will then set the property and notify all linked objects about the changes using a PROPERTY_CHANGE message, including the original sender.  &lt;-- [ PROPERTY_CHANGE, &quot;org.demos.Echo/message&quot;, &quot;foo&quot;]   ","version":"Next","tagName":"h2"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Property Synchronization","url":"/docs/advanced/objectlink/properties#sequence-diagram","content":" After an object is linked propertie will be synced across all linked clients.  ","version":"Next","tagName":"h2"},{"title":"Actions Reference","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/actions","content":"","keywords":"","version":"Next"},{"title":"$set​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#set","content":" The $set action sets a value of a property. The default case it sets the value of the default interface. The value can be a primitive or a object.  # set the property `count` to `0` $set: { count: 0 }   Or using an object  # set the property `position` to `{ x: 10, y: 20 }` $set: { position: { x: 10, y: 20 } }   The set command will change the property value and also emit a property change signal. The change signal is emitted automatically when a property is changed using the $set action.  ","version":"Next","tagName":"h2"},{"title":"$update​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#update","content":" The $update action updates a partial value of a property. The default case it updates the value of the default interface. The value can be a primitive or a object. Different from $set the value is merged with the existing value.  This is useful when the value is an object and only a part of the object needs to be changed.  # set the property `position` to `{ x: 10, y: 20 }` - $set { position: { x: 10, y: 20 } } # partially update the property `position` property to `{ x: 30, y: 20 }` - $update { position: { x: 30 } }   ","version":"Next","tagName":"h2"},{"title":"$signal​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#signal","content":" The $signal action emits a signal from the simulation. The default case it emits the signal from the default interface. The value is an array of arguments, which are the arguments of the signal, as defined in the API.  For example a signal shutdown with an argument timeout can be emitted like this:  # emit the signal `shutdown` with the argument `timeout` set to `5` $signal: { shutdown: [ 5 ] } x   note To directly emit a signal from the client it is possible to use invoke operation, but with a $signal. prefix of the signal name. For example to emit the shutdown signal from the client it can be done like this: client.invoke(&quot;$signal.shutdown&quot;, [ 5 ]) This will send the invoke message to the simulation and the simulation will emit the signal. There is no return value from the invoke operation.  ","version":"Next","tagName":"h2"},{"title":"$return​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#return","content":" The $return action returns a result from an operation. The default case it returns the result from the default interface. The value to return is given in the result key of the action object.  For example a result 1 from an operation it can be returned like this:  # returns the result `1` from the operation $return: { result: 1 }   To return an object as result, use the result key:  note If several return commands are used in a step, only the last one is returned.  # will return the result `{ x: 10, y: 20 }` from the operation $return: { result: { x: 10, y: 20 } }   The receiving client must know the type of the result to be able to parse it.  ","version":"Next","tagName":"h2"},{"title":"$change​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#change","content":" The $change action emits a property change signal from the simulation. The default case it emits the signal from the default interface. The value is property name and the new value.  # emits the property change signal `count` with value `1` $change: { count: 1 }   The change command will not change the property. It is used to simulate a property change from the outside. The change signal is emitted automatically when a property is changed using the $set action.  It is also possible to change several properties at once:  # emits the property change signal `count` and 'position' with their values $change: { count: 1, position: { x: 10, y: 20 } }   ","version":"Next","tagName":"h2"},{"title":"$call​","type":1,"pageTitle":"Actions Reference","url":"/docs/advanced/simulation/actions#call","content":" The $call action calls an operation from the simulation. The default case it calls the operation from the default interface. The value is the operation name and the arguments.  # calls the operation `increment` with the argument `1` inside the simulation $call: { increment: [1] }   note You need to make sure you do not recurse into an infinite loop, by calling an operation that calls the same operation again.  You can also call several operations at once. We can currently not guarantee the order of operations. The last operation result is returned. If an error occurs, the error is returned and no result.  # will call the operation `increment` with the argument `1` # and then call the operation `decrement` with the argument `1` $call: { increment: [1], decrement: [1] }  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/intro","content":"","keywords":"","version":"Next"},{"title":"What is a simulation?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation","content":" A simulation is a virtual representation of a service. It can be used to test, demonstrate or develop applications without the need to have the actual service available.  ","version":"Next","tagName":"h2"},{"title":"What is a simulation server?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation-server","content":" A simulation server is a server which hosts one or more simulations in form fo scenarios. It can be used to test, demonstrate or develop applications without the need to have the actual service available.  ","version":"Next","tagName":"h2"},{"title":"What is a simulation scenario?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation-scenario","content":" A simulation scenario is a set of interfaces and their properties, operations, signals which can be loaded into a simulation server. A scenario can react to operations and can also be used to change properties or send signals.  A scenario allows also to define sequences of actions which can be triggered by an operation call or by name. The actions can change the property values of the service or send signals.  Simulation scenarios can be written using a YAML schema.  Based on our counter demo we can write a YAML based scenario like this.  schema: apigear.scenario/1.0 name: &quot;demo scenario&quot; version: &quot;1.0&quot; interfaces: - name: demo.Counter: properties: count: 0 operations: - name: increment: actions: - $set { count: 10 } - name: decrement: actions: - $set { count: -10 } - name: demo.Echo: operation: - name: say: actions: - $return { result: &quot;Hello World&quot; }   This is a simple scenario which imitate a demo.Counter and demo.Echo interface.  When this scenario is loaded into the simulation server a client can just call these simulation operations. This scenario does not include sequences.  ","version":"Next","tagName":"h2"},{"title":"What is a simulation protocol?​","type":1,"pageTitle":"Introduction","url":"/docs/advanced/simulation/intro#what-is-a-simulation-protocol","content":" A simulation protocol is a way to interact with a simulation server. It defines how to call operations, how to get the state of an interface and how to trigger sequences. The simulation server currently supports the ObjectLink protocol which is available in the ObjectLink section. ","version":"Next","tagName":"h2"},{"title":"Server Side Signals","type":0,"sectionRef":"#","url":"/docs/advanced/objectlink/signals","content":"","keywords":"","version":"Next"},{"title":"ApiGear Object Model​","type":1,"pageTitle":"Server Side Signals","url":"/docs/advanced/objectlink/signals#apigear-object-model","content":" Signals can be modeled using ApiGear as signals of an interface.  name: org.demos interfaces: - name: Echo signals: - name: shutdown params: - name: timeout type: int   The resulting code will look somehow like this and most often will require a lambda function to be used for the notification.  // org.demos.js class Echo { onShutdown(callback) } const echo = new Echo() echo.onShutdown( (timeout) =&gt; { console.log('timeout: ', timeout); })   ","version":"Next","tagName":"h2"},{"title":"Protocol Flow​","type":1,"pageTitle":"Server Side Signals","url":"/docs/advanced/objectlink/signals#protocol-flow","content":" To receive signals the local object needs to be linked to the remote object first.  --&gt; [ LINK, &quot;org.demos.Echo&quot;]   Then the remote object can send at any time signals to the linked client objects and notify them on changes.  &lt;-- [ SIGNAL, &quot;org.demos.Echo/shutdown&quot;, [10]]   To stop receiving signals, just unlink the remote object.  --&gt; [ UNLINK, &quot;org.demos.Echo&quot;]   ","version":"Next","tagName":"h2"},{"title":"Sequence Diagram​","type":1,"pageTitle":"Server Side Signals","url":"/docs/advanced/objectlink/signals#sequence-diagram","content":" After an object is linked server side signals will be send.  ","version":"Next","tagName":"h2"},{"title":"Network Protocol","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/protocols","content":"","keywords":"","version":"Next"},{"title":"Example​","type":1,"pageTitle":"Network Protocol","url":"/docs/advanced/simulation/protocols#example","content":" In the following we will use always our counter example which looks like this:  schema: apigear.module/1.0 name: demo version: &quot;1.0&quot; interfaces: - name: Counter properties: - name: count type: int operations: - name: increment params: - name: step type: int - name: decrement params: - name: step type: int - name: Echo operations: - name: say params: - name: message type: string return: - type: string   We can identify an operation using an URI like this demo.Counter/increment and a service like this demo.Counter.  As a convention, calling the service should always give back the current state, which is the sum of properties. Calling an operation should always return a valid value defined by the return type.  ","version":"Next","tagName":"h2"},{"title":"ObjectLink Protocol for Simulation​","type":1,"pageTitle":"Network Protocol","url":"/docs/advanced/simulation/protocols#objectlink-protocol-for-simulation","content":" The simulation server can be called using the ObjectLink protocol over WebSockets. The protocol is described in the ObjectLink specification.  An incoming object link message is wired to a scenario document. Each scenario document can contain multiple interfaces. The interface name is used to identify the interface to be simulated. The operation name is used to identify the operation to be simulated. In case no scenario document is provided, the simulation server will use a default scenario document.  ","version":"Next","tagName":"h2"},{"title":"Feeding the Simulation Server​","type":1,"pageTitle":"Network Protocol","url":"/docs/advanced/simulation/protocols#feeding-the-simulation-server","content":" The simulation server can be fed with a a set of JSON messages arranged in a new-line separated JSON file. The file can be provided using the --feed command line option of the CLI. The file can be used to feed the simulation server with a set of messages. The messages are sent to the simulation server in the order they are provided in the file. The file can be used to feed the simulation server with a set of messages. The messages are sent to the simulation server in the order they are provided in the file.  Feeding a simulation server is a great way to validate your simulation scenario or even your object-link service. ","version":"Next","tagName":"h2"},{"title":"Simulation with Studio","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/studio","content":"","keywords":"","version":"Next"},{"title":"Connection​","type":1,"pageTitle":"Simulation with Studio","url":"/docs/advanced/simulation/studio#connection","content":" To connect to the ApiGear Studio simulation server you need to know the connection address, which can be queries from the settings panel.  The connection address in the form of ws://127.0.0.1/5554 or parts of it needs to be made available to your API SDK. Please consult the dedicated SDK readme about the correct procedure.  ","version":"Next","tagName":"h2"},{"title":"Monitoring​","type":1,"pageTitle":"Simulation with Studio","url":"/docs/advanced/simulation/studio#monitoring","content":" There is no dedicated view for monitoring the simulation calls. These calls can be monitored using the API monitor as part of the API calls. ","version":"Next","tagName":"h2"},{"title":"Code Generation","type":0,"sectionRef":"#","url":"/docs/cli/generate","content":"","keywords":"","version":"Next"},{"title":"Quick Code Generation​","type":1,"pageTitle":"Code Generation","url":"/docs/cli/generate#quick-code-generation","content":" The apigear command line tool can be used to generate code from an API definition. The following example shows how to generate code from the a demo API definition.  // demo.idl module demo 1.0 interface Counter { count: int increment() decrement() }   For example to generate a C++ 14 SDK from the demo API definition just run the following command.  apigear generate expert -i demo.idl -o tmp -t apigear-io/template-cpp14   The expert mode is used to generate code from an IDL file. The -i option specifies the input file. The -o option specifies the output directory. The -t option specifies the template to use. The template-cpp14 template is used to generate C++ 14 code.  If the template does not point to a local directory the template will be downloaded from the template registry and installed in a local cache directory.  By default the latest version of the template is used. To use a specific version of the template add the version to the template name using the @&lt;version&gt; syntax.  ","version":"Next","tagName":"h2"},{"title":"Solution based Code Generation​","type":1,"pageTitle":"Code Generation","url":"/docs/cli/generate#solution-based-code-generation","content":" To streamline the code generation you can create a configuration file called solution. The following example shows how to create a configuration file for the C++ 14 SDK.  # solution.yaml layers: - name: cpp14 inputs: - demo.idl output: tmp template: template-cpp14   The layers section defines the layers of the solution. Each layer defines a set of inputs, an output directory and a template. The inputs section defines the input files for the layer. The output section defines the output directory for the layer. The template section defines the template to use for the layer.  To generate the code from the solution just run the following command.  apigear generate solution solution.yaml  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/cli/intro","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/docs/cli/intro#installation","content":" The apigear command line tool is available for Linux, MacOS and Windows. It can be installed from the release page.  ","version":"Next","tagName":"h2"},{"title":"Update​","type":1,"pageTitle":"Introduction","url":"/docs/cli/intro#update","content":" The apigear command line tool can be updated using the update command.  apigear update   It will ask for confirmation and then download the latest version of the apigear command line tool. ","version":"Next","tagName":"h2"},{"title":"Scenario Documents","type":0,"sectionRef":"#","url":"/docs/advanced/simulation/scenario","content":"","keywords":"","version":"Next"},{"title":"Action​","type":1,"pageTitle":"Scenario Documents","url":"/docs/advanced/simulation/scenario#action","content":" At several places the scenario uses action sequences. A sequence is a list of actions each action is an object with a key of the action command and a array value as the action arguments.  - $cmd: { cmd-options }   When an action modifies a property, the property change signal is emitted automatically.  Typical actions are  $set - sets a value - $set: { count: 1 }similar to set('count', 1) $signal - emits a signal from the simulation - $signal: { shutdown: { timeout: 5 } }similar to emit signal('shutdown', { timeout: 5} ) $return - returns a result from an operation: - $return: { count: 1 }similar to return { count: 1 }  ","version":"Next","tagName":"h2"},{"title":"Sequences​","type":1,"pageTitle":"Scenario Documents","url":"/docs/advanced/simulation/scenario#sequences","content":" A sequence is a list of actions, organized into steps. Each step is executed in order. Actions of a step are also executed in order. A sequence can be looped or stepped through using an interval.   ```yaml sequence: - name: increment counter interval: 2000 # 2 seconds loop: true # start over when at end steps: # step is called every 2 secs according to interval - name: increment actions: # list of actions - $set: { count: 1 } - $signal: { shutdown: [ 5 ] } - name: clear actions: - $set: { count: 0 } - $signal: { shutdown: [ 5 ] } }   The interval defined the tick and on each tick a step is running. If loops is true then the playbook will start again after finished. ","version":"Next","tagName":"h2"},{"title":"API Monitoring","type":0,"sectionRef":"#","url":"/docs/cli/monitor","content":"","keywords":"","version":"Next"},{"title":"Quick API Monitoring​","type":1,"pageTitle":"API Monitoring","url":"/docs/cli/monitor#quick-api-monitoring","content":" API Monitoring is a feature of the ApiGear platform. It allows to monitor the traffic of an API. The apigear command line tool can be used to monitor an API. The following example shows how to monitor the demo API.  apigear monitor run   This will start the API monitoring server. The server will listen on port 5555. To change the port use the --port option.  The monitoring server will listen for API calls. Normally the API events will come from a running API client. It is also possible to feed API events using the feed command.  The following example shows how to feed API event to the monitor using a new line delimited json document (NDJSON).  // demo.ndjson { &quot;id&quot;: &quot;1&quot;, &quot;kind&quot;: &quot;call&quot;, &quot;symbol&quot;: &quot;demo.Counter/increment&quot; } { &quot;id&quot;: &quot;2&quot;, &quot;kind&quot;: &quot;state&quot;, &quot;symbol&quot;: &quot;demo.Counter&quot;, &quot;props&quot;: { &quot;count&quot;: 99 } } }   apigear monitor feed demo.ndjson   This will send the API calls to the monitoring server. The monitoring server will print the API calls to the console.  tip Currently the monitoring server does not store the API calls. This will be added in a future release with a playback feature. ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/docs/cli/project","content":"","keywords":"","version":"Next"},{"title":"Create a new project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#create-a-new-project","content":" To create a project use the new command.  apigear project new &lt;project-name&gt;   ","version":"Next","tagName":"h2"},{"title":"List recent projects​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#list-recent-projects","content":" To list all projects use the list command.  apigear project list   It will show the recently used projects first.  ","version":"Next","tagName":"h2"},{"title":"Delete a project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#delete-a-project","content":" To delete a project use the delete command.  apigear project delete &lt;project-name&gt;   ","version":"Next","tagName":"h2"},{"title":"Switch between projects​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#switch-between-projects","content":" To switch between projects use the switch command.  apigear project switch &lt;project-name&gt;   It will switch the current project to the specified project.  ","version":"Next","tagName":"h2"},{"title":"Project configuration​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#project-configuration","content":" The project command stores the project configuration in the &lt;project&gt;/.apigear file. The configuration file contains the following information.  # .apigear { &quot;folder&quot;: &quot;apigear&quot;, }   The folder property specifies the folder where the project configuration is stored. The default value is apigear.  ","version":"Next","tagName":"h2"},{"title":"Create documents in the project folder​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#create-documents-in-the-project-folder","content":" The create command allows you to create documents in the project folder. The following documents can be created: API Modules, API Solutions and API Scenarios.  apigear create &lt;document-type&gt; &lt;document-name&gt;   The document will be created in the apigear folder of the current project. The document-type can be one of the following values: module, solution or scenario.  ","version":"Next","tagName":"h2"},{"title":"Pack a Project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#pack-a-project","content":" The pack command allows you to pack a project. It will create a zip file containing all project documents.  apigear project pack &lt;project-name&gt;   ","version":"Next","tagName":"h2"},{"title":"Share a Project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#share-a-project","content":" The share command allows you to share a project. It will create a zip file containing all project documents and upload it to the ApiGear platform.  apigear project share &lt;project-name&gt;   tip This feature is currently not available and will be added in a future release.  ","version":"Next","tagName":"h2"},{"title":"Import a Project​","type":1,"pageTitle":"Project Management","url":"/docs/cli/project#import-a-project","content":" The import command allows you to import a project. It will download a zip file containing all project documents from the ApiGear platform and unpack it.  apigear project import &lt;project-name&gt;   tip This feature is currently not available and will be added in a future release. ","version":"Next","tagName":"h2"},{"title":"API Simulation","type":0,"sectionRef":"#","url":"/docs/cli/simulate","content":"","keywords":"","version":"Next"},{"title":"Quick API Simulation​","type":1,"pageTitle":"API Simulation","url":"/docs/cli/simulate#quick-api-simulation","content":" API Simulation is a feature of the ApiGear platform. It allows to simulate the behavior of an API. The apigear command line tool can be used to simulate an API. The following example shows how to simulate the demo API.  API simulation is based on a simulation scenario. The following example shows how to create a simulation scenario for the demo API.  # demo.scenario.yaml interfaces: - name: demo.Counter props: count: 0 operations: - name: increment actions: - $set: { count: 1 } - name: decrement actions: - $set: { count: 0 }   Now we can run the simulation server using the following command.  apigear simulate run demo.scenario.yaml   The simulation server will listen on port 5555. To change the port use the --port option. It will load the simulation scenario from the demo.scenario.yaml file. The simulation server will listen for API calls. Normally the API calls will come from a running API client. It is also possible to feed API calls using the feed command.  The following example shows how to feed API calls to the simulation server using a new line delimited json document (NDJSON).  { &quot;method&quot;: &quot;simu.state&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter&quot; }} { &quot;method&quot;: &quot;simu.call&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter/increment&quot;, &quot;data&quot;: { &quot;step&quot;: 1 } }} { &quot;method&quot;: &quot;simu.call&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter/decrement&quot;, &quot;data&quot;: { &quot;step&quot;: 2 } }} { &quot;method&quot;: &quot;simu.state&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter&quot;, &quot;data&quot;: { &quot;count&quot;: 4 } }} { &quot;method&quot;: &quot;simu.state&quot;, &quot;params&quot;: { &quot;symbol&quot;: &quot;demo.Counter&quot; }}   To feed the API calls to the simulation server just run the following command.  apigear simulate feed demo.ndjson   This will send the API calls to the simulation server. The simulation server will print the API calls to the console. ","version":"Next","tagName":"h2"},{"title":"Help","type":0,"sectionRef":"#","url":"/docs/community/help","content":"","keywords":"","version":"Next"},{"title":"How to get help​","type":1,"pageTitle":"Help","url":"/docs/community/help#how-to-get-help","content":" Asks question in the GitHub discussion forum or issue tracker.  Slack DiscussionsGitHub DiscussionsGitHub Issues  ","version":"Next","tagName":"h2"},{"title":"How to report a bug​","type":1,"pageTitle":"Help","url":"/docs/community/help#how-to-report-a-bug","content":" Report a bug in the GitHub issue tracker. Please include the following information:  Version of the CLI Steps to reproduce the bug Expected behavior Actual behavior GitHub Issues  ","version":"Next","tagName":"h2"},{"title":"How to request a feature​","type":1,"pageTitle":"Help","url":"/docs/community/help#how-to-request-a-feature","content":" Request a feature in the GitHub issue tracker. Please include the following information:  Description of the feature Use case for the feature Alternatives considered GitHub Issues ","version":"Next","tagName":"h2"},{"title":"SDK Templates","type":0,"sectionRef":"#","url":"/docs/cli/template","content":"","keywords":"","version":"Next"},{"title":"Search Templates​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#search-templates","content":" You can search for templates using the apigear template search command. The command will search for templates in the cloud and print the result.  apigear template search &lt;name&gt;   The name argument is optional. If you specify a name the command will search for templates with a matching name. If you omit the name the command will search for all templates.  ","version":"Next","tagName":"h2"},{"title":"Install a Template​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#install-a-template","content":" To install a template you need to know the name of the template. The name is the same as the name of the template in the ApiGear Registry. You can find the name in the template details page.  apigear template install &lt;name&gt;   The name argument is the name of the template. The command will install the template in the local template folder. The default location is ~/.apigear/templates. You can change the location using the APIGEAR_TEMPLATES environment variable.  Template Info  You can get information about a template using the apigear template info command. The command will print the details of the template.  apigear template info &lt;name&gt;   The information includes the name, version, description and features of the template.  Update a Template  To update a template you need to know the name of the template. The name is the same as the name of the template in the ApiGear Registry. You can find the name in the template details page.  apigear template update &lt;name&gt;   The update will update to the latest version by default but it's also possible to specify a version.  ","version":"Next","tagName":"h2"},{"title":"Remove a Template​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#remove-a-template","content":" You can remove a template by name. The name can be found using the list command.  apigear template remove &lt;name&gt;   ","version":"Next","tagName":"h2"},{"title":"List Installed Templates​","type":1,"pageTitle":"SDK Templates","url":"/docs/cli/template#list-installed-templates","content":" You can list all installed templates using the apigear template list command. The command will print the name and version of all installed templates.  apigear template list  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/guide/intro","content":"","keywords":"","version":"Next"},{"title":"Development Cycle​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#development-cycle","content":" This is section is about how to use ApiGear to create SDKs with the ObjectAPI.  tip Feel free to jump directly to our demos over at github. They showcase two different APIs in several languages including applications which use the API modules.  Now, that you know the basics about the ObjectAPI and how to create SDKs using ApiGear, we provide some demos and hints for real world projects.  We will cover starting from scratch as well as updating an existing API, previously created using ApiGear. Our demos are implemented using the same process as described below.  ","version":"Next","tagName":"h2"},{"title":"Cycle Overview​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#cycle-overview","content":"   The graphic describes the development cycle using ApiGear.  Like every modern development tool ApiGear fully supports an agile development approach. You can start with a minimal API definition and then iteratively add more functionality or change existing details. Theoretically, you could even rewrite the whole API. However, using the API first approach will help you design more stable and high quality APIs.  ","version":"Next","tagName":"h2"},{"title":"Define API​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#define-api","content":" As with every API first approach you start at defining your ObjectAPI module. This can be done using the ApiGear Studio or the ApiGear CLI. An API module is a simple document following the ObjectAP specification.  ","version":"Next","tagName":"h2"},{"title":"Create SDK​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#create-sdk","content":" Once you have created one or several API modules you are set to create your first SDK. Therefore you choose one of our expert engineered SDK templates and a SDK runner for your project.  The SDK runner will create a .zip file for you to download.  ","version":"Next","tagName":"h2"},{"title":"Apply Changes​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#apply-changes","content":" The aforementioned SDK .zip file consists of several different files depending on the SDK runner setup and chosen programming language.  Assuming you chose the &quot;full package including scaffolding&quot; then you have the following types of files:  The plain API in your preferred languageA stub implementation derived from this API with a basic implementationA suite of test files covering the stub implementationProject files to instantaneously build the whole API module and execute the test casesAdditional adapters created by ApiGear to provide API analytics insights.  From here on we recommend a split strategy depending on whether you created the API module for the first time or whether you want to update an existing implementation.  ","version":"Next","tagName":"h2"},{"title":"First run​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#first-run","content":" The easiest way to set your project up for long time API updates is to create an ini(tial) folder within your project and extract the SDK unmodified in this folder. Afterwards you just simply copy this ini folder to a sol(ution) folder. You should then commit this state as initial version to be able to always rollback.  Once this is done you can start replacing the API stub implementation in the sol folder with your business logic and the same time update the test stubs to cover the real API behavior.  ","version":"Next","tagName":"h3"},{"title":"Updating existing APIs​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#updating-existing-apis","content":" When you have set up your project as described in the first run using a ini and sol folder - or a similar setup - you can now easily apply updates to your API using the following steps.  extract the updated SDK unmodified into the ini folder. A diff of your preferred source control tool should only should the auto generated changes based on your API modificationuse a compare and merge tool to go over the differences of the updated ini folder and your existing implementation in the sol folderonly apply the interface changes without overwriting your business logic  This process might sound cumbersome on first sight but is really easy and straight forward to use.  ","version":"Next","tagName":"h3"},{"title":"Create application​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#create-application","content":" Now, that we have our API module in place we can start using it an application. Depending on whether it is the same team or a different team implementing the application, they can use the module either with a stub implementation, a simulation adapter or the real business logic. There is no dependency anymore - the API module and the application can be both developed in parallel based on the commonly defined API description.  Our demos were developed the same way as described above. Small increments at a time, super fast and with high quality built in. The applications are stored in the app(lication) folder.  ","version":"Next","tagName":"h2"},{"title":"Gain insights​","type":1,"pageTitle":"Introduction","url":"/docs/guide/intro#gain-insights","content":" With the upcoming feature ApiGear analytics you will gain full insight into your customers API usage. Based on this highly valuable feedback you are able to make fully informed decisions on which feature to extend or which could be spared for future efficiency and customer satisfaction. ","version":"Next","tagName":"h2"},{"title":"ApiGear Core","type":0,"sectionRef":"#","url":"/docs/intro","content":"","keywords":"","version":"Next"},{"title":"What is ApiGear?​","type":1,"pageTitle":"ApiGear Core","url":"/docs/intro#what-is-apigear","content":" ApiGear is a set of tools and services that allow teams to create a description of their software interfaces and generate a ready to use integration SDK. The SDK comes already pre-configured with support for monitoring, logging, and tracing and simulation of interface calls.  ","version":"Next","tagName":"h2"},{"title":"What is an API?​","type":1,"pageTitle":"ApiGear Core","url":"/docs/intro#what-is-an-api","content":" An API is a set of rules that define how software components communicate with each other. It is a contract between the software components. The API defines the data structure and the behavior of the software components. It is a description of the software interfaces.  ","version":"Next","tagName":"h2"},{"title":"What is an API Module?​","type":1,"pageTitle":"ApiGear Core","url":"/docs/intro#what-is-an-api-module","content":" An API module is a description of an API. It is a document that contains the API description. It is a description of the software interfaces. A set of modules define a software system. The modules are the building blocks of the system. API modules can be transformed into SDKs using the ApiGear Studio and the ApiGear CLI.  ","version":"Next","tagName":"h2"},{"title":"What is an API SDK?​","type":1,"pageTitle":"ApiGear Core","url":"/docs/intro#what-is-an-api-sdk","content":" An API SDK is a set of software components that reflect the API module content. It allows to focus on the API usage and less on the implementation details. The SDK is a ready to use integration component that can be used to integrate the software system with other systems. ","version":"Next","tagName":"h2"},{"title":"Counter API Demo","type":0,"sectionRef":"#","url":"/docs/guide/counter","content":"","keywords":"","version":"Next"},{"title":"Using the API​","type":1,"pageTitle":"Counter API Demo","url":"/docs/guide/counter#using-the-api","content":" The generated code will result in a C++ class with some abstract methods. The API has no functionality yet, and needs to be provided by you. So open the project in your favorite editor and add the implementation.  // counter.h void Counter::increment() { // add implementation here count++; }   Now, you can use the class in your main function.  // main.cpp #include &lt;iostream&gt; using namespace std; #include &quot;counter.h&quot; int main(int argc, char**argv) { Counter counter; cout &lt;&lt; counter.count(); counter.increment(); cout &lt;&lt; counter.count(); }   Which concrete API you will use depends on the code generators you configure. There are code-generators for many languages and technologies available.  We can now continue to design the API inside the APIGear's API editor.  The editor allows us to save the API at any point and to create a new version if required.  ","version":"Next","tagName":"h2"},{"title":"Documentation​","type":1,"pageTitle":"Counter API Demo","url":"/docs/guide/counter#documentation","content":" To make the API more descriptive we can add some description.  The API language has full support for markdown based descriptions.  To write code examples just indent the code snippets  schema: apigear.module/1.0 name: demo.daily version: &quot;1.0&quot; description: A module to demonstrate an API interfaces: - name: Counter description: An interface to increment a coffee counter properties: - name: count type: int description: holds the current count value operations: - name: increment description: increments the count value   After saving the API module, we can see the documentation in the API portal. It is automatically updated, based on the API module content.  Now, we have successfully defined an API. The next step will be to use the API. First in a playground like environment, later in a real project. ","version":"Next","tagName":"h2"},{"title":"Calculator API Demo","type":0,"sectionRef":"#","url":"/docs/guide/calculator","content":"","keywords":"","version":"Next"},{"title":"Defining an API Module​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#defining-an-api-module","content":" From inside a project we create a new API module called demo.calc using the Create Module action and create a new interface named 'Calculator'.  schema: apigear.module/1.0 name: demo.calc version: &quot;1.0&quot; interfaces: - name: Calculator   A typical calculator always displays the current value calculated. We will add this as a property to the interface.  interfaces: - name: Calculator properties: - name: value type: int   We expect the value is always updated when a number was entered and a new operation is entered.  We add the first operation add to the calculator. It takes one parameter and the number to be added.  interfaces: - name: Calculator operations: - name: add params: - name: a type: int   Let's add the rest of the calculator operations and the clear action.  schema: apigear.module/1.0 name: demo.calc version: &quot;1.0&quot; interfaces: - name: Calculator properties: - name: value type: int operations: - name: add params: - name: a type: int - name: subtract params: - name: a type: int - name: multiply params: - name: a type: int - name: divide params: - name: a type: int - name: clear   We added all missing calculator operations. The clear action will reset the calculator value to 0.  ","version":"Next","tagName":"h2"},{"title":"Python Interface​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#python-interface","content":" For our implementation we configure a Python SDK as runner and generate our calculator SDK. The abstract calculator interface will look like this:  # demo_calc.py class AbstractCalculator(object): def __init__(self): self.value = 0 def add(a: int): raise NotImplementedError def subtract(a: int): raise NotImplementedError def multiply(a: int): raise NotImplementedError def divide(a: int): raise NotImplementedError def clear(a: int): raise NotImplementedError   ","version":"Next","tagName":"h2"},{"title":"Sample Implementation​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#sample-implementation","content":" To implement the interface we derive from the abstract calculator and implement the missing operations. A simple implementation could look like this.   # import our generated interfaces import org_daily class Calculator(demo_calc.AbstractCalculator): def add(a: int): self.value += a def subtract(a: int): self.value -= a def multiply(a: int): self.value *= a def divide(a: int): self.value /= a def clear(a: int): self.value = 0   ","version":"Next","tagName":"h2"},{"title":"API Updates​","type":1,"pageTitle":"Calculator API Demo","url":"/docs/guide/calculator#api-updates","content":" The next time we change the API module we need to update the abstract interface and ensure all changed operations are implemented.  It is very easy now to add implementations also for other programming languages or even for a micro service using one of the many supported SDK templates. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/sdk/intro","content":"Introduction ApiGear comes with a collection of SDK templates which allows our users to create code interfaces but also complete SDKs from the API Modules. A template is a transformation of a group of API modules into source code for your software project. All template SDKs can scale with your project by adding more API modules. A command line tool will support you with merging the updated SDK code. These templates can be configured by enabling and disabling certain features. Also SDKs are build on top of certain ObjectAPI profiles, which enable or disable certain language features. A user will get a warning when an API uses features not available in the configured language profile. An SDK will come with all build and test related dependencies and ready to use for your project. The SDK scales with your requirements by adding more API modules which are automatically added to the build infrastructure and tests. ApiGear offers currently several SDKs for major programming languages and technologies and more will come over time.","keywords":"","version":"Next"},{"title":"Golang SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/go-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Golang SDK Template","url":"/docs/sdk/go-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract C++ class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  type Counter interface { GetCount() int SetCount(count int) Increment() }   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Golang SDK Template","url":"/docs/sdk/go-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a C++ class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a Go struct type. As these API structs shall be able to be used outside of the module the fields are public.  type Message struct { Text string = &quot;&quot; }   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Golang SDK Template","url":"/docs/sdk/go-sdk#enumerations","content":" A enumeration will be transformed to a set of constants.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  type Direction int const ( Up = 1 Down = 2 Left = 3 Right = 4 )  ","version":"Next","tagName":"h2"},{"title":"Python SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/python-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Python SDK Template","url":"/docs/sdk/python-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  class ICounter: @property def count(self): raise NotImplementedError def increment(self): raise NotImplementedError   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Python SDK Template","url":"/docs/sdk/python-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a python class. As these API structs shall be able to be used outside of the module the fields are public.  class Message: def __init__(self): self.text : str = str()   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Python SDK Template","url":"/docs/sdk/python-sdk#enumerations","content":" A enumeration will be transformed to a set of constants.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  from enum import Enum class Direction(Enum): Up = 0 Down = 1 Left = 2 Right = 3  ","version":"Next","tagName":"h2"},{"title":"C++ 14 SDK template","type":0,"sectionRef":"#","url":"/docs/sdk/cpp14-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"C++ 14 SDK template","url":"/docs/sdk/cpp14-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract C++ class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  class CounterBase { public: CounterBase(){}; virtual ~CounterBase(){}; // methods virtual void increment() = 0; // property methods virtual void setCount(int count) = 0; virtual int count() const = 0; };   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"C++ 14 SDK template","url":"/docs/sdk/cpp14-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a C++ class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a Qt C++ class with public fields.  class Message { public: Message(); void setText(const std::string&amp; text); std::string text() const; bool operator==(const Message &amp;other) const; bool operator!=(const Message &amp;other) const; private: std::string m_text; };   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"C++ 14 SDK template","url":"/docs/sdk/cpp14-sdk#enumerations","content":" A enumeration will be transformed to a standalone class with an enum embedded.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  class Direction { public: Direction() {} enum DirectionEnum { Up = 0, Down = 1, Left = 2, Right = 3 }; static DirectionEnum toEnum(std::uint8_t v, bool *ok); };  ","version":"Next","tagName":"h2"},{"title":"First Steps","type":0,"sectionRef":"#","url":"/docs/start/first_steps","content":"","keywords":"","version":"Next"},{"title":"Using the Studio​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#using-the-studio","content":" When you run the Studio for the first time you need to accept our TOS once. This is a requirement to get the Studio working.  ","version":"Next","tagName":"h2"},{"title":"First Project​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#first-project","content":" APIs are collected inside a project. A project is a folder with an apigear folder inside. The folder contains the API description and other documents to help you with the project.  To create the first project you click New Project project overview. A dialog does open to select a folder for your new project. Ideally you create an empty folder before or you create one in this dialog. When you click OK the project will be created and an apigear folder will be created inside the selected folder.  Now you have an empty project without any APIs. You can add APIs to the project by clicking New -&gt; API Module documents overview. The dialog will open to name your new API. When clicking OK the API will be created and a new document will be shown n the overview.  The view has now changed to the Api Modules view. Here you see all your API modules and actions to manage them. To edit and API you can click the Edit icon. It will open the API editor, which is normally Visual Studio Code.  You can now edit and save the API Module. API modules structure and meaning is defined in the ObjectAPI Specification.  ","version":"Next","tagName":"h2"},{"title":"Install Code Templates​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#install-code-templates","content":" To create your first SDK from API modules we need to have Code Templates installed and a configuration file, called solution.  In the Templates view you see all templates available from the ApiGear cloud. You can install templates by clicking the Install button. The templates are installed in a local folder on you drive.  The name of a template will be used later for creating a SDK from the API modules.  ","version":"Next","tagName":"h2"},{"title":"Create a Solution​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#create-a-solution","content":" A solution binds API modules with an SDK. It can contain several layers of code generation. For example you can generate a C++ SDK from the API modules, as also a Python SDK. All templates have also different features for example http or olink support. Which features are supported is different for each template.  tip In the ObjectAPI Mapping is a description how different APIs are mapped to different transports and protocols.  A solution is a document and can be created using the New -&gt; Solution action. The dialog allows you to name the solution. When clicking OK the solution will be created and a new document will be shown. Also the view has changed to the &quot;Solution&quot; view.  To edit the solution click the Edit icon. The solution will be opened in the editor.  Now you can add our inputs to the solution. Inputs can be API modules in the form of the YAML of IDL format. As also the template we installed earlier.  layers: - name: &quot;C++&quot; inputs: - &lt;name&gt;.module.yaml output: &quot;../output&quot; template: &lt;template-name&gt;   Make sure you also have added an output folder where the SDK will be generated. The output folder is relative to the solution document.  A solution can have several layers and each layer can have many modules. This is how you can create even complex solutions with one run.  ","version":"Next","tagName":"h2"},{"title":"Code generation​","type":1,"pageTitle":"First Steps","url":"/docs/start/first_steps#code-generation","content":" The code generator is driven by the solution. It will generate the code based on the solution content. To run the solution we need to be in the &quot;Solution&quot; view and click Run next to one of the solutions.  A dialog will appear and you see the code generation progress. At the end a short summary will be printed.  You code is now generated in the output folder. In case you want to see the generated code you can open the output folder in your favorite file explorer.  tip In case an error appears the generation will be stopped and the error will be displayed. ","version":"Next","tagName":"h2"},{"title":"Qt C++ SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/qtcpp-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Qt C++ SDK Template","url":"/docs/sdk/qtcpp-sdk#interfaces","content":" An interface like this counter will be directly transformed to an abstract C++ class.  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The class will then later be used to be implemented by the customer.  class AbstractCounter : public QObject { Q_OBJECT public: AbstractCounter(QObject * parent=nullptr); virtual void setCount(int count) = 0; virtual int count() const = 0; virtual void increment() = 0; Q_SIGNALS: void countChanged(int count); };   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Qt C++ SDK Template","url":"/docs/sdk/qtcpp-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a C++ class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a Qt C++ gadget so it can be also be used later in QML.  class Message { Q_GADGET Q_PROPERTY(QString text READ text WRITE setText) public: Message(); void setText(const QString&amp; text); QString text() const; bool operator==(const Message &amp;other) const; bool operator!=(const Message &amp;other) const; private: QString m_text; }; Q_DECLARE_METATYPE(Message)   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Qt C++ SDK Template","url":"/docs/sdk/qtcpp-sdk#enumerations","content":" A enumeration will be transformed to a standalone class with an enum embedded.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  class Direction : public QObject { Q_OBJECT public: Direction(QObject *parent = nullptr) : QObject(parent) {} enum DirectionEnum { Up = 0, Down = 1, Left = 2, Right = 3, }; Q_ENUM(DirectionEnum) static DirectionEnum toEnum(quint8 v, bool *ok); };  ","version":"Next","tagName":"h2"},{"title":"Installation","type":0,"sectionRef":"#","url":"/docs/start/install","content":"","keywords":"","version":"Next"},{"title":"Install Apigear Studio​","type":1,"pageTitle":"Installation","url":"/docs/start/install#install-apigear-studio","content":" ApiGear Studio can be downloaded from Github Releases Site. Studio is available for Mac, Windows and Linux.  After installation you can start the ApiGear Studio.  As ApiGear Studio is still in early access version there are no certificates yet. Which requires you on Windows and MacOS to accept some exceptions.  ","version":"Next","tagName":"h2"},{"title":"Install ApiGear CLI​","type":1,"pageTitle":"Installation","url":"/docs/start/install#install-apigear-cli","content":" ApiGear CLI is a command line tool to generate code from API modules. It is available for Mac, Windows and Linux. You can download the latest version from Github Releases Site.  The CLI provides all features of the Studio. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/studio/intro","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Introduction","url":"/docs/studio/intro#installation","content":" The desktop studio is available for Linux, MacOS and Windows. It can be installed from the release page.  ","version":"Next","tagName":"h2"},{"title":"Update​","type":1,"pageTitle":"Introduction","url":"/docs/studio/intro#update","content":" The desktop studio will automatically check for updates and prompt you to update when a new version is available. The update will be downloaded in the background and installed when you restart the application.  The update is checked once per application start.  tip There are currently no certificates for the update server. This means that you will get a warning when you start the application for the first time.There is currently no support for manually check for updates. This feature will be added in the future. ","version":"Next","tagName":"h2"},{"title":"Typescript SDK Template","type":0,"sectionRef":"#","url":"/docs/sdk/typescript-sdk","content":"","keywords":"","version":"Next"},{"title":"Interfaces​","type":1,"pageTitle":"Typescript SDK Template","url":"/docs/sdk/typescript-sdk#interfaces","content":" An interface like this counter will be directly transformed to an TypeScript interface  interfaces: - name: Counter properties: - name: count type: int operations: - name: increment   The interface will then later be used to be implemented by the customer. A reference implementation is created by the scaffold feature.  export interface ICounter { count: number increment(): void }   ","version":"Next","tagName":"h2"},{"title":"Data Structures​","type":1,"pageTitle":"Typescript SDK Template","url":"/docs/sdk/typescript-sdk#data-structures","content":" A data structure like this message which contains one field, called text is transformed into a class with public fields.  structs: - name: Message fields: - name: text type: string   A data structure is transformed to a class with public fields.  export class Message { text: string; }   ","version":"Next","tagName":"h2"},{"title":"Enumerations​","type":1,"pageTitle":"Typescript SDK Template","url":"/docs/sdk/typescript-sdk#enumerations","content":" A enumeration will be transformed to a set of constants.  enums: - name: Direction members: - name: Up - name: Down - name: Left - name: Right   This is transformed to  export enum Direction { Up = 0, Down = 1, Left = 2, Right = 3, }  ","version":"Next","tagName":"h2"},{"title":"Project Management","type":0,"sectionRef":"#","url":"/docs/studio/project","content":"","keywords":"","version":"Next"},{"title":"Create project​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#create-project","content":" To create a new project, click the New project button. It will open the Create project dialog. it shows a folder select dialog. Select the folder where you want to create the project. The project name will be the name of the selected folder. Inside the folder a new folder will be created with the name apigear. This folder will contain the project configuration and all documents.  ","version":"Next","tagName":"h2"},{"title":"Open project​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#open-project","content":" To open an existing project, click the Open project button. It will open the Open project dialog. It shows a folder select dialog. Select the folder where the project is located. The project name will be the name of the selected folder. The project configuration and all documents will be loaded from the apigear folder inside the selected folder.  ","version":"Next","tagName":"h2"},{"title":"Import project​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#import-project","content":" To import an existing project, click the Import project button. It will open the Import project dialog. It shows a folder select dialog. Select the folder where the project is located. The project name will be the name of the selected folder. The project configuration and all documents will be copied from the selected folder to the apigear folder inside the selected folder.  ","version":"Next","tagName":"h2"},{"title":"Recent projects​","type":1,"pageTitle":"Project Management","url":"/docs/studio/project#recent-projects","content":" To open a recent select one of the recent projects. It will open the project. ","version":"Next","tagName":"h2"},{"title":"Quick start","type":0,"sectionRef":"#","url":"/docs/studio/quickstart","content":"","keywords":"","version":"Next"},{"title":"Project Selection​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#project-selection","content":" ","version":"Next","tagName":"h2"},{"title":"Documents​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#documents","content":" ","version":"Next","tagName":"h2"},{"title":"Code Generation​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#code-generation","content":" ","version":"Next","tagName":"h2"},{"title":"Monitoring​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#monitoring","content":" ","version":"Next","tagName":"h2"},{"title":"Simulation​","type":1,"pageTitle":"Quick start","url":"/docs/studio/quickstart#simulation","content":"","version":"Next","tagName":"h2"},{"title":"Features","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features","content":"","keywords":"","version":"Next"},{"title":"Get started​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#get-started","content":" This template generates code for pure c++ projects. In order to successfully compile and use the code, you need to have a working c++ compiler toolchain installed.  note Basic c++ knowledge is necessary.  ","version":"Next","tagName":"h2"},{"title":"Code generation​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#code-generation","content":" Follow the documentation for the code generation in general and CLI or the Studio tools. Or try first the quick start guide which shows how to prepare api and generate code out of it.  tip For questions regarding the template please go to our discussions page. For feature requests or bug reports please use our issue tracker.  ","version":"Next","tagName":"h3"},{"title":"Example API​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#example-api","content":" The following code snippet contains the API definition which is used throughout this guide to demonstrate the generated code and its usage.  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#features-1","content":" ","version":"Next","tagName":"h2"},{"title":"Core Features​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#core-features","content":" Features generate a view model for the API definition. This can be used to implement a working C++ service and directly use it in your project.  api - generates compilable base pure interfaces for your API, as also a basic implementation for data types and subscriber/publisher as abstract classes that describe the notification system for users of your interfaces.stubs - adds a basic stub implementation for the API, you'll get classes that can actually be instantiated with a ready to use publishers, this is a good starting point for your implementation.conan - build and packaging support for your project.  ","version":"Next","tagName":"h3"},{"title":"Extended Features​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#extended-features","content":" Features can be used in combination with API and add more functionality on top, like simulation support (see olink)  olink - provides a client and server adapters for each interface, that can be connected to any of the other technology templates with support for ObjectLink. Use this feature to connect with ApiGear simulation tools.examples_olink - examples of generated code for the olink feature. Contains: olinkserver shows use of your interfaces as an olink services.olinkclient shows use of your interfaces as an olink clients. monitor - generates a middle-ware layer which logs all API events to the CLI or the StudioMQTT experimental - provides minimal working adapters for MQTT client and service side for each interfaces. Check also MQTT in other technology templates that supports it.examples_mqtt - examples of generated code for the olink feature. Contains: mqttserver shows use of your interfaces with mqtt adapted for your services.mqttclient shows use of your interfaces as a mqtt adapted for your services users. examples of generated code for basic features: app simple example with stubs.appthreadsafe simple example with stubs wrapped with thread safe decorator. See thread safe decorator from core features  Figure: Overview of features for user application, including receiving data from network: Bottom floor shows possible inputs for your API, you can either obtain data from the network with OLink or MQTT or use local (thread safe if necessary) implementation.  note Theoretically you can use the Thread Safe Decorator with other features that implements API: OLinkClient and MQTT Client, but they, already provide thread safety on at least the same level as the Thread Safe Decorator.  Figure: Overview of features for user application, including publishing data through network: Topmost floor shows your options for using your local implementation (bottom floor): you can use it in your local app and/or use method of sharing the data with clients in the network. Consider then using thread safe version of your implementation.  There are also an internal features:  apigear, which is generated for the extended features and is explained with them.core, which is generated for the stubs and the extended features. For the explanation see core documentation  Each feature can be selected using the solution file or via command line tool.  note _Features are case sensitive, make sure to always use lower-case. _  tip The meta feature all enables all specified features of the template. If you want to see the full extent of the generated code all is easiest solution. Please note, all is part of the code generator and not explicitly used within templates.  ","version":"Next","tagName":"h3"},{"title":"Folder structure​","type":1,"pageTitle":"Features","url":"/template-cpp14/docs/features#folder-structure","content":" This graph shows the full folder structure which is generated for all features enabled, but skips the conan files. Generated features are encapsulated in separate folders for each module or for the common features like examples and the internal helper feature apigear, a level above, in the generation target level, here cpp_hello_world. For more details visit the documentation for each feature.  📂hello-world ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂conan ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┃ ┣ 📂api ┃ ┃ ┃ ┃ ┣ 📂core ┃ ┃ ┃ ┃ ┣ 📂monitor ┃ ┃ ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┃ ┗ 📂olink ┃ ┃ ┃ ┣ 📂implementation ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┗ 📜Io_worldConfig.cmake.in ┃ ┗ 📜CMakeLists.txt  ","version":"Next","tagName":"h2"},{"title":"Conan package manager","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features/conan","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"Conan package manager","url":"/template-cpp14/docs/features/conan#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   The files for conan will be generated for project:  📂hello-world ┣ 📂apigear ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┃ ... ┃ ┃ ┗ 📜conanfile.py ┃ ┣ 📂examples ┃ ┃ ┣ 📂 app ┃ ┃ ┃ ... ┃ ┃ ┃ ┗ 📜conanfile.txt ┃ ┃ ... ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂conan ┃ ┃ ┃ ┃ ┣ 📂test_package ┃ ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┃ ┣ 📜conanfile.py ┃ ┃ ┃ ┃ ┃ ┗ 📜main.cpp ┃ ┃ ┃ ┃ ┗ 📜conanfile.py ┣ 📂scripts ┃ ┣ 📜test_conan.bat ┃ ┣ 📜test_conan.sh   ","version":"Next","tagName":"h3"},{"title":"Run scripts​","type":1,"pageTitle":"Conan package manager","url":"/template-cpp14/docs/features/conan#run-scripts","content":" The top level files you'll find in '📂hello-world/cpp_hello_world' 📜test_conan.bat (for windows) and 📜test_conan.sh (for linux based systems) contain set of command line commands to build whole project. The scripts build the project twice:  Firstly, using a package development commands. This way is recommended for local development, testing and modifications/customization of the build process in the user space without recompiling the entire package. Used command is conan build .. (preceded by source command that copies necessary sources and install command which installs the requirements and generates the info files). You can read more about build here.Secondly, with one of conan creator commands conan create .... It is primarily used to generate, package, and upload packages to a repository. It calls the local conanfile.py ‘package()’ method. The conanfile.py is located in the 📂modules and created for each module separately. Creator Commands are more geared toward recipe creation, versioning, and repository interactions. You can read more about package here.  We use CMake build system with conan.  tip Modify the script to suit your needs. You can choose one of the building methods depending on current stage of your package development lifecycle.  Some of the above files, the 📂cpp_hello_world/apigear/conanfile.py or conanfiles.txt generated for each example were present even without conan feature - for simplicity of generation rules. The 📂cpp_hello_world/apigear/conanfile.py contains recipe for building additional library - network layer for cpp-template, independent from your API, and necessary for ObjectLink core, for aligning to MQTT protocol or for tracing. The 📂cpp_hello_world📂modules/io_world/conan/conanfile.py is the main recipe for your API module, which contains all the info necessary for packaging. Dependencies for the examples are stored in conanfile.txt files in each of the examples ( conanfile.txt is a simplification of conanfile.py, that can be used exclusively to consume dependencies, but not to create packages).  The test package Files inside the 📂cpp_hello_world/modules/io_world/conan/test_package contain a test package. It instantiates Hello implementation from a stub feature. It is a check that package for io_world was created in proper way, can be found and used. ","version":"Next","tagName":"h3"},{"title":"Monitor","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features/monitor","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"Monitor","url":"/template-cpp14/docs/features/monitor#file-overview-for-module","content":" With our example API definition  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┃ ... ┃ ┃ ┣ 📂tracer ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜tracer.cpp ┃ ┃ ┃ ┣ 📜tracer.h ┃ ┃ ┃ ┗ 📜tracer.test.cpp ┃ ┣ 📂examples ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┃ ┣ 📂monitor ┃ ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.tracedecorator.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.tracedecorator.h ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.tracer.cpp ┃ ┃ ┃ ┃ ┃ ┗ 📜hello.tracer.h ...   ","version":"Next","tagName":"h2"},{"title":"Interface Independent Trace Client​","type":1,"pageTitle":"Monitor","url":"/template-cpp14/docs/features/monitor#interface-independent-trace-client","content":" When generating the monitor feature (or olink feature) you'll get an additional folder in the top most directory:📂hello-world/apigear. The 📂tracer subfolder contains a client for logging, with a network layer (based on the POCO library). The class connects to the Apigear Trace Server and takes care of formatting and sending the traces.  ","version":"Next","tagName":"h3"},{"title":"Monitor​","type":1,"pageTitle":"Monitor","url":"/template-cpp14/docs/features/monitor#monitor-1","content":" Files 📜hello.tracedecorator.h and 📜hello.tracedecorator.cpp contain the trace wrapper for the Hello interface. The wrapper will be generated for each interface inside the API definition.  class HELLO_WORLD_EXAMPLE_IO_WORLD_EXPORT HelloTraceDecorator : public IHello, public IHelloSubscriber { explicit HelloTraceDecorator(IHello&amp; impl, ApiGear::PocoImpl::Tracer&amp; tracer) ... };   The tracer uses the implementation of IHello - wraps each interface operation call and the notifications of property changed and signal emitted with a lgo to a monitor tool. The other calls are just forwarded to your implementation - so you can use the HelloTraceDecorator as a Hello object.  note The wrapped object IHello&amp; impl is just the object that fulfills the IHello interface, so the implementation can be e.g. the OlinkClient version of Hello.  The 📜hello.tracer.h and 📜hello.tracer.cpp files contain helper to prepare interface specific trace data for the general tracing TraceClient  ","version":"Next","tagName":"h3"},{"title":"Tracing example​","type":1,"pageTitle":"Monitor","url":"/template-cpp14/docs/features/monitor#tracing-example","content":" Prepare an application (generate for both examples and monitor features) that uses the tracer:   int main(){ ApiGear::PocoImpl::Tracer tracer; tracer.connect(&quot;http://localhost:8182&quot;, &quot;testExampleApp&quot;); std::unique_ptr&lt;IoWorld::IHello&gt; helloImplementation = std::make_unique&lt;IoWorld::Hello&gt;(); std::unique_ptr&lt;IoWorld::IHello&gt; tracedHello = IoWorld::HelloTraceDecorator::connect(*helloImplementation, tracer); // use your tracedHello as it was Hello implementation, all property changes, and signals and method execution and function calls will be traced. auto lastMessage = tracedHello-&gt;getLast(); tracedHello-&gt;say(lastMessage, IoWorld::WhenEnum::Soon); IoWorld::Message someMessage(&quot;the new content&quot;); tracedHello-&gt;setLast(someMessage); tracedHello-&gt;_getPublisher().publishJustSaid(someMessage); return 0; }   Make sure that you are using the same port for sending and receiving traces. For sending: check yor setting for ApiGear::PocoImpl::Tracer. For receiver: go to the ApiGear Studio settings and set correct port number. By default the address is set to ws://localhost:8182/ws. ","version":"Next","tagName":"h3"},{"title":"API Feature","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features/api","content":"","keywords":"","version":"Next"},{"title":"Files overview per module​","type":1,"pageTitle":"API Feature","url":"/template-cpp14/docs/features/api#files-overview-per-module","content":" Using the example API definition  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated inside the target folder. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┃ ┣ 📂api ┃ ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┃ ┣ 📜common.h ┃ ┃ ┃ ┃ ┃ ┣ 📜datastructs.api.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜datastructs.api.h ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.api.h ┃ ┃ ┃ ┃ ┃ ┗ 📜io_world.h .. .   ","version":"Next","tagName":"h3"},{"title":"Enums and Structures​","type":1,"pageTitle":"API Feature","url":"/template-cpp14/docs/features/api#enums-and-structures","content":" Files datastructs.api.h and datastructs.api.cpp contain core data structures and enumerations used in your module.  Enums​  Inside the datastructs.api.h you will find all the enums defined in your API. For each enum there is a enum class generated with all the values defined.  For convenience of use each enum has a toEnum function, which converts given uint8_t to enum value.  Structs​  All structs defined in your API are generated in datastructs.api.h and datastructs.api.cpp files. They are used to communicate data between your API and its users.  For convenience of use each structure has:  equality comparison operatorsempty constructor and a constructor with parameters for all its fields.  ","version":"Next","tagName":"h3"},{"title":"Interfaces​","type":1,"pageTitle":"API Feature","url":"/template-cpp14/docs/features/api#interfaces","content":" For each interface inside an AP module there is separate file generated, like the 📜hello.api.h.  The interface class contains pure virtual functions as well as pure virtual subscriber and publisher classes.  The interface has:  pure virtual getters and a setters for each property virtual void setLast(const Message&amp; last) = 0; virtual const Message&amp; getLast() const = 0; pure virtual functions for each operation virtual int say(const Message&amp; msg, When::WhenEnum when) = 0; and their asynchronous versions virtual std::future&lt;int&gt; sayAsync(const Message&amp; msg, WhenEnum when) = 0; an access to a publisher The interface does not contain signals defined in your interface, the signals feature is achieved with a subscriber/publisher mechanism.  A class interested in notification on signal emission (and property changes) needs to use the publisher to subscribe for those events. The important thing is that your implementation of the interface should notify the IHelloPublisher about emitted signals or state changed.  note Notice the convention for the getter - we use an underscore _ - this function is added by the generator to your interface. The underscore is used to prevent name collision with your implementation of the interface. virtual IHelloPublisher&amp; _getPublisher() const = 0;   Publisher​  The IHelloPublisher provides the interface for subscribing and unsubscribing from a signal emission or a property change. Use of such a class is mandatory for implementation and allows users of your API to react on changes.  The publisher is responsible for keeping its clients informed about requested changes. But it is the interface (here IHello) implementation responsibility to call the publish functions from its API when signal or property change occurs e.g:  void Hello::setLast(const Message&amp; last) { ... // call the publish function m_publisher-&gt;publishLastChanged(last); }   There are two ways of subscribing for changes.  Either provide an implementation for ISubscriber interface class and use is with those publisher's functions  void subscribeToAllChanges(IHelloSubscriber&amp; subscriber); void unsubscribeFromAllChanges(IHelloSubscriber&amp; subscriber);   The subscribe ISubscriber assures your subscriber will be informed about all emitted signals and all property changes.  The other option is to use the parallel system of notification which doesn't require the ISubscriber and informs your Interface user about change of specific property or signal emission. E.g for LastChanged property we have:  long subscribeToLastChanged(HelloLastPropertyCb callback); // returns handleId that needs to be used to unsubscribe void unsubscribeFromLastChanged(long handleId);   The publisher will execute the provided callback function each time and only when this property is changed.  caution For both methods of subscribing make sure to remove subscription for a ISubscriber/callback before it becomes invalid. Also make sure that the subscribed function is not blocking and returns immediately!  The publish functions need to be called by the implementation of the IHello on each property change or signal emission to notify all the subscribers about this change.  note Subscriptions systems are parallel - if you use both of them for single interface user i.e subscribe your class as an ISubscriber and for a single change your subscriber will be informed twice about that change, one for each subscription mechanism. This means that the unsubscribe functions for both mechanisms work only for that mechanism, i.e. the unsubscribe with ISubscriber will not remove any subscriptions for the specific property/signal and they stay intact.  Subscriber​  For each interface we generate the ISubscriber, for example here the IHelloSubscriber which contains a set of functions for all the properties and signals for the notification mechanism.  The implementation for IHello contains a publisher which can be used to subscribe for those changes called IHelloSubscriber. Each time publisher will receive publish request it will notify all subscribed IHelloSubscriber object about change. You can use IHelloSubscriber class to implement your local clients of the IHello or a network service adapter - see Olink Server.  Below is a small code snippet which shows an example implementation for IHelloSubscriber, a class which main functionality is reacting on changes in Hello.  class HelloUser : public IHelloSubscriber { public: HelloUser(IHello&amp; Hello) : m_Hello(Hello) { m_Hello._getPublisher().subscribeToAllChanges(*this); } ~HelloUser() { m_Hello._getPublisher().unsubscribeFromAllChanges(*this); } void onJustSaid(const Message&amp; /*msg*/) override { // do something with msg. } void onLastChanged(const Message&amp; /*last*/) override { // do something with last; } // Some other functionality. private: IHello&amp; m_Hello }   ","version":"Next","tagName":"h3"},{"title":"Other​","type":1,"pageTitle":"API Feature","url":"/template-cpp14/docs/features/api#other","content":" 📜 CMakeLists.txt for building this module, describing it's dependencies, and exposing built package for other features that will use it. 📜 common.h prepares dll import/export statements. ","version":"Next","tagName":"h3"},{"title":"Template C++ 14","type":0,"sectionRef":"#","url":"/template-cpp14/docs/intro","content":"Template C++ 14 This is the documentation for the cpp14 template for the ApiGear code generator. It is split in several parts: Quick-Start is the easiest way to get startedFeatures explains the available code generator features and their usage and purpose.","keywords":"","version":"Next"},{"title":"MQTT","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features/mqtt","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"MQTT","url":"/template-cpp14/docs/features/mqtt#file-overview-for-module","content":" With our API definition  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure is generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜mqttclient.cpp ┃ ┃ ┃ ┣ 📜mqttclient.h ┃ ┃ ┃ ┣ 📜mqttservice.cpp ┃ ┃ ┃ ┣ 📜mqttservice.h ┃ ┃ ┃ ┣ ... (helper files) ┃ ┃ ... ┃ ┣ 📂examples ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┃ ┣ 📜helloclient.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜helloclient.h ┃ ┃ ┃ ┃ ┃ ┣ 📜helloservice.cpp ┃ ┃ ┃ ┃ ┃ ┗ 📜helloservice.h ...   ","version":"Next","tagName":"h2"},{"title":"ApiGear MQTT - The Network Layer​","type":1,"pageTitle":"MQTT","url":"/template-cpp14/docs/features/mqtt#apigear-mqtt---the-network-layer","content":" When using the mqtt feature (or any of those: olink, monitor feature) you'll get an additional folder at the top most directory: the 📂hello-world/cpp_hello_world/apigear. The 📂mqtt subfolder contains objects that implement a network layer (based on PAHO library) for the MQTT protocol. Those are:  Client - Adapts the MQTT client, to serve as an network endpoint for interface client adapters. Exposes: methods that allow receiving data from remote service: subscribing for properties changes, signals emission and method response invocation; methods that allow remote using the service: requesting property change or invoking a method. The client may serve many client interface adapters, even for the same interfaces (allows subscribing for same topic). In case many interface client adapters for same interface are connected: property changes and signals are provided to all the interface client adapters, but the invoke method response will be delivered only for the one that requested it. ServiceAdapter - Adapts the MQTT client to serve as an network endpoint for interface service adapters. Exposes: methods that allow receiving requests from remote clients: subscribing for properties change requests, send method invocation; methods that allow publishing property change, signal, functionality to handles sending a response for method invocation requests. This ServiceAdapter may be used for many interface service adapters, but it is not recommended to use more than one interface service adapter for same interface.  tip Have in mind that MQTT might not be suitable for high-frequency messages especially with one mqtt client serving more than one object. Also the brokers have limits for messages number/size queued from one client. In case you are not getting all the messages consider changing those or splitting traffic between more clients (maybe some handle the properties, some handle the methods).  ","version":"Next","tagName":"h3"},{"title":"MQTT Client Adapter​","type":1,"pageTitle":"MQTT","url":"/template-cpp14/docs/features/mqtt#mqtt-client-adapter","content":" Files 📜helloclient.h and 📜helloclient.cpp implement the remote client for the Hello interface - a HelloClient class. The object is an IHello implementation. It requires an instance of Apigear::Mqtt::Client to work. It uses the Client to subscribe (and unsubscribe) for topics that allow receiving properties, signals and invoke responses from service.  Properties​  The property getters (here getLast() ) return immediately the locally stored,last received value from service. The property setter (here void setLast(const Message&amp; last) ) requests setting a value on service side, local value is not changed. You can subscribe to a property change event (here last property ) through the publisher which you can get from the API with _getPublisher(). Or you can subscribe as an IHelloSubscriber and get all changes. See publisher and subscriber for more info on subscribing. When the client receives information that server changed the property, a target property (here last) is updated locally and a notifies subscribers that property has changed.  note The connected interface client adapter has its local properties in sync with a service. The messages with property changes are retained in MQTT broker, so all properties which are already set are provided.  Operations​  The operations have an async version, which is called by the immediate version.  The async version sends an invoke operation request to a server.  So calling myHelloClientInstance.say(myWhen) implements execution of sayAsync and waits for the result (for non-void type of operations). Have in mind that this is a blocking operation.  Signals​  You should not emit any signals from a client.  You can subscribe to any signals offered by your interface (here justSaid) signal), through the publisher. You can either select the signal you're interested in, or subscribe as an IHelloSubscriber to get all the signals and property change notifications.  When a HelloClient client receives the message from server that indicates the signal was emitted it notifies all the subscribers that requested this notification..  Use HelloClient​  HelloClient is an adapter of Mqtt (with protocol and network layer implementation), here provided by a ApiGear::MQTT::Client. All you need to do is to pass the ApiGear::MQTT::Client to your Interface Client Adapter, and request connecting to host when it is convenient for you.  // Create a client and make a connection auto mqttclient = std::make_shared&lt;ApiGear::MQTT::Client&gt;(&quot;UniqueClientName&quot;); // set up modules auto ioWorldHello = std::make_unique&lt;IoWorld::MQTT::HelloClient&gt;(mqttclient); // start mqtt connection mqttclient.connectToHost(&quot;tcp://localhost:1883&quot;); // Use the same port number as your broker is using. Typically, without any other settings it is &quot;1883&quot;. // use your ioWorldHello as it was Hello implementation ioWorldHello-&gt;say(IoWorld::WhenEnum::Soon); auto lastMessage = ioWorldHello-&gt;getLast(); IoWorld::Message someMessage(&quot;the new content&quot;); ioWorldHello-&gt;setLast(someMessage); testIoWorldHello-&gt;_getPublisher().subscribeToJustSaid([](auto args) { /*handle the signal*/});   ","version":"Next","tagName":"h3"},{"title":"MQTT Server Adapter​","type":1,"pageTitle":"MQTT","url":"/template-cpp14/docs/features/mqtt#mqtt-server-adapter","content":" The files 📜helloservice.h and 📜helloservice.cpp contain the MQTT service side adapter for the Hello interface - the HelloService class. It uses the general MQTT service adapter ApiGear::MQTT::Service.  HelloService object exposes the local object for remote usage with the MQTT protocol. It handles all the network requests, and calls on your local object. The client connections and communication with them is handled transparently for you, no additional actions are needed.  Properties​  Each time a property of your the Hello interface implementation changes, a message is sent to all connected clients with information, which property changed to which value. It is true for both - local calls on the Hello object, by other local Hello users or when a change property request message is received by this HelloService (the HelloService applies the property on your local Hello object and then the HelloService is triggered).  Operations​  The operations invocation which was triggered from the clients through the network will be performed on your local Hello object. The result of the operation (if any) will be returned only to the client, from which the message was send, not all clients.  Signals​  All the signals emitted by your local Hello objects are forwarded as an MQTT message to all connected clients.  note Have in mind that the Hello implementation is not thread safe by default.  Use HelloService​  HelloService is an adapter of Mqtt (with protocol and network layer implementation), here provided by a ApiGear::MQTT::ServiceAdapterAll you need to do is to pass the ApiGear::MQTT::ServiceAdapter and a local Hello implementation to your HelloService Adapter, then request connecting to host whenever convenient for you.  auto mqttservice = std::make_shared&lt;ApiGear::MQTT::Service&gt;(&quot;ServiceUniqueNameInMqtt&quot;); auto ioWorldHello = std::make_shared&lt;IoWorld::Hello&gt;(); IoWorld::MQTT::HelloService mqttHelloService(ioWorldHello, mqttservice); // start mqtt connection mqttservice-&gt;connectToHost(&quot;tcp://localhost:1883&quot;); // use your ioWorldHello as it was Hello implementation, all property changes, and signals will be passed to connected MqttHello clients. ioWorldHello-&gt;say(IoWorld::WhenEnum::Soon); IoWorld::Message someMessage(&quot;the new content&quot;); auto lastMessage = ioWorldHello-&gt;getLast(); ioWorldHello-&gt;setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value. testIoWorldHello-&gt;_getPublisher().publishJustSaid(someMessage);   ","version":"Next","tagName":"h3"},{"title":"MQTT Messages​","type":1,"pageTitle":"MQTT","url":"/template-cpp14/docs/features/mqtt#mqtt-messages","content":" In case you want construct messages for client or server side on your own, please check how topics are created and how does the payload look like, check this document messages format. ","version":"Next","tagName":"h3"},{"title":"Stubs","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features/stubs","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"Stubs","url":"/template-cpp14/docs/features/stubs#file-overview-for-module","content":" With our example API definition  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┃ ┣ 📂api ┃ ┃ ┃ ┃ ┣ 📂core ┃ ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.data.h ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.publisher.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.publisher.h ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.threadsafedecorator.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜hello.threadsafedecorator.h ┃ ┃ ┃ ┃ ┃ ┣ 📜io_world.json.adapter.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜io_world.json.adapter.h ┃ ┃ ┃ ┃ ┃ ┗ 📜io_world.test.cpp ┃ ┃ ┃ ┣ 📂implementation ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┣ 📜hello.cpp ┃ ┃ ┃ ┃ ┣ 📜hello.h ┃ ┃ ┃ ┃ ┗ 📜hello.test.cpp ...   ","version":"Next","tagName":"h3"},{"title":"Implementation​","type":1,"pageTitle":"Stubs","url":"/template-cpp14/docs/features/stubs#implementation","content":" Files 📜hello.h and 📜hello.cpp contain the implementation of the IHello. The class skeleton:  adds the properties of the interface as a private class members - with a HelloData structure implements getters and setters for each property owns a publisher and shares it through the _getPublisher method implementation provides empty implementation of operation for you to fill the business logic. tip When adding a logic don't forget to use the publisher each time you want the property change to be shared or the signal to be emitted. note We generate the import/export statements, here HELLO_WORLD_EXAMPLE_IO_WORLD_EXPORT, for all the classes and structs that have an implementation in a cpp file and may be used outside of the library.  ","version":"Next","tagName":"h3"},{"title":"Core​","type":1,"pageTitle":"Stubs","url":"/template-cpp14/docs/features/stubs#core","content":" Publisher​  Files 📜hello.publisher.cpp and 📜hello.publisher.h provide an implementation of a IHelloPublisher (api.md#Publisher). It stores clients of the Hello (either the IHelloSubscribers or callbacks for specific change). When a call of the appropriate publish function is executed on the publisher instance, it informs all of interested clients about the change.  This class is thread safe in a way that adding and removing subscribers (both for full interface or specific notifications) is thread safe. If you use publisher from many threads for notification you need to make sure that ISubscriber or the callbacks are thread safe or modify the publisher to use them in thread-safe way. You may also want to take a look at generated IHello thread safe decorator.  Data​  The 📜hello.data.h contains the helper structure for implementations of Hello. It stores all the properties that an interface has and initializes them to default values.  Thread Safe Decorator​  Files 📜hello.threadsafedecorator.cpp and 📜hello.threadsafedecorator.h provide a wrapper for your IHello implementation which can be used to make property access thread safe.  For each property it allows multiple get operations at the same time but only one set. The properties are guarded one by one - so at one time you can write to different properties.  Operations are not guarded by default - the implementation may either be thread safe by design (const, re-entrant) or too complex to simply lock it.  So depending on the logic in your methods you can decide to leave them without any mutexes, add same mechanism as for properties in the implementation file of the Hello interface, or try different solutions like introducing an event queue.  Json adapters​  Files 📜io_world.json.adapter.cpp and 📜io_world.json.adapter.h are generated per whole module. They prepare adapters for structs to easy convert to and from nlohmann::json. This is currently used by our implemented protocols for the data packing. With this implementation you use the structures as below  Message message = json.get&lt;Message&gt;(); nlohmann::json message = message;   ","version":"Next","tagName":"h3"},{"title":"Tests​","type":1,"pageTitle":"Stubs","url":"/template-cpp14/docs/features/stubs#tests","content":" For each interface we provide a template for your tests: 📜hello.test.cpp. We used Catch2 for setting up a test skeleton. You can find there instantiating the interface, section with executing methods (no checks) and section with setting a property with check that it actually happen. That is a starting point for your tests.  tip In case you'll need mocks, Catch2 goes well along with trompeloeil. ","version":"Next","tagName":"h3"},{"title":"Features","type":0,"sectionRef":"#","url":"/template-python/docs/features","content":"","keywords":"","version":"Next"},{"title":"Get started​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#get-started","content":" This template generates code for Python projects. In order to successfully compile and use the code, you need to have the Python installed (at least 3.12). Check the Python website for downloads. Basic understanding of Python is required.  ","version":"Next","tagName":"h2"},{"title":"Code generation​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#code-generation","content":" Follow the documentation for the code generation in general and CLI or the Studio tools. Or try first the quick start guide which shows how to prepare api and generate code out of it.  tip For questions regarding this template please go to our discussions page. For feature requests or bug reports please use the issue tracker.  ","version":"Next","tagName":"h3"},{"title":"Example API​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#example-api","content":" The following code snippet contains the API which is used throughout this guide to demonstrate the generated code and its usage in Python.  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#features-1","content":" ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#core","content":" Features generate a view model for the api. This can be used to implement a working service and directly use it in your UI project.  [api] TBD - generates abstract base interface and a basic implementation for data types[stubs] TBD - adds a basic stubs for the api, you'll get classes that can be instantiated and have some default behavior.  ","version":"Next","tagName":"h3"},{"title":"Extended​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#extended","content":" Features can be used in combination with api and add more functionality on top, like the simulation  [olink] TBD - provides a client and server adapters for each interface, that can be connected to any of the other technology templates with support for ObjectLink. Use this feature to connect with ApiGear simulation tools.[MQTT] TBD - provides minimal working adapters for MQTT client and service side for each interfaces. Check also MQTT in other technology templates that supports it. Also examples are provided: examples/mqtt/server.py that shows usage of your services in mqtt server adapter.examples/mqtt/client.py that shows usage of your interfaces in mqtt client adapter.  There is also an internal feature apigear, which is generated for the extended features, its usage is explained with the extended features. Each feature can be selected using the solution file or via command line tool.  note *Features are case sensitive, make sure to always use lower-case. *  tip The meta feature all enables all specified features of the template. If you want to see the full extent of the generated code all is easiest solution. Please note, all is part of the code generator and not explicitly used within templates.  ","version":"Next","tagName":"h3"},{"title":"Folder structure​","type":1,"pageTitle":"Features","url":"/template-python/docs/features#folder-structure","content":" This graph shows the full folder structure which is generated for all features enabled. Generated features are encapsulated in separate folders inside the module folder, here io_world or for the common features like examples and the internal helper feature apigear, a level above, in the generation layer level, here qt_hello_world. For more details visit the documentation for each feature.  📂hello-world ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂py_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┃ ┣ 📂mqtt ┃ ┃ ┗ 📂olink ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂impl ┃ ┃ ┣ 📂mqtt ┃ ┃ ┗ 📂olink ┃ ┣ 📂utlis ┃ ┗ 📜requirements.txt  ","version":"Next","tagName":"h2"},{"title":"Quick-Start","type":0,"sectionRef":"#","url":"/template-cpp14/docs/quickstart","content":"","keywords":"","version":"Next"},{"title":"1. Install the code generator​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#1-install-the-code-generator","content":" Get the ApiGear Studio or ApiGear CLI. For more information check the ApiGear documentation.  ","version":"Next","tagName":"h2"},{"title":"2. Get the template​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#2-get-the-template","content":" There are several options to get the template. Installation via the Studio or the CLI. Alternatively it is possible to clone or download from github.  ","version":"Next","tagName":"h2"},{"title":"Installation via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#installation-via-cli","content":" When using the CLI only the highlighted line is imported. You can always check whether the installation was successful via the template list command.  $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-cpp14 | false | true | https://github.com/apigear-io/template-cpp14.git ... $ apigear template install apigear-io/template-cpp14 $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-cpp14 | true | true | https://github.com/apigear-io/template-cpp14.git ...   ","version":"Next","tagName":"h3"},{"title":"Installation via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#installation-via-studio","content":" From within the studio the installation is really simple.  Open an existing project or create an new oneGo to the Templates tabClick Install on the apigear-io/template-cpp14 entry  ","version":"Next","tagName":"h3"},{"title":"Clone from github​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#clone-from-github","content":" In case you want to check or modify the source code of the template, it is easier to clone or download the repository. The repository does not need to be part of the project, but can be stored anywhere on the computer.  $ git clone https://github.com/apigear-io/template-cpp14.git   You can then point the solution file to use your template from its directory by providing relative path from the solution file.  ","version":"Next","tagName":"h3"},{"title":"3. Set up project​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#3-set-up-project","content":" For a project we usually need two files. The solution which specifies what APIs and which template to use for it. And at least one API module file. Both should ideally be in a folder called apigear next to each other.  Alternatively, you can also use the Studio to create a new project and modify the two example files.  ","version":"Next","tagName":"h2"},{"title":"Solution file​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#solution-file","content":" Create a solution file. The example below specifies  module files in line 8, here the helloworld.module.yaml module with Hello APIthe output directory for generated files in line 9a template used to generate the code in line 10, here the apigear-ui/template-cpp14 template. This can also be a path to a local copy of the template.the enabled features of the template in line 13, here the stubs feature, a simple implementation of interfaces. For all available features check the overview.  helloworld.solution.yaml schema: &quot;apigear.solution/1.0&quot; name: hello_world_example version: &quot;0.1.0&quot; targets: - name: cpp_hello_world inputs: - helloworld.module.yaml output: ../cpp_hello_world template: apigear-io/template-cpp14 force: true features: - stubs   Targets You can extend this solution file with other targets, each for the different technology with different template. The module.yaml is technology independent and may be used for any template.  note Set the force parameter to true if you want to always override all the generated files. With option set to false some files, like implementation (stub feature) won't be updated. All the API files are always updated.  ","version":"Next","tagName":"h3"},{"title":"API module file​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#api-module-file","content":" Use your favorite text editor to create the helloworld.module.yaml with the example content:  helloworld.module.yaml schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"4. Generate code​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#4-generate-code","content":" With the output directory set as in example, both ApiGear files reside in an apigear subfolder next to the cpp generated files. In this case the folder structure should look similar to this  📂hello-world ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂cpp_hello_world ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┣ 📂implementation ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┣ 📜hello.cpp ┃ ┃ ┃ ┃ ┣ 📜hello.h ┃ ┃ ┃ ┃ ┗ 📜hello.test.cpp ┃ ┗ 📜CMakeLists.txt   Using the solution file from the previous paragraph the code will be generated in the cpp_hello_world folder. With subfolder for each module, here io_world as the name of module (defined in line 2 of helloworld.module.yaml). It contains both features generated: a basic api and a stub implementation.  ","version":"Next","tagName":"h2"},{"title":"Generate via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#generate-via-cli","content":" The following snippet shows how the CLI can be run.  $ apigear generate solution apigear/helloworld.solution.yaml 10:52:20 INF generated 21 files in 30ms. (20 write, 0 skip, 1 copy) topic=gen   generate tells the CLI that it should generate codesolution specifies that we want to run a solution file  ","version":"Next","tagName":"h3"},{"title":"Generate via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#generate-via-studio","content":" Open the projectGo to the Solutions tabClick Run on the helloworld.solution.yaml entry  ","version":"Next","tagName":"h3"},{"title":"5. Use the generated cpp project.​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#5-use-the-generated-cpp-project","content":" The generated code provides cpp C++ implementations. The following paragraphs show how you can use it. You can start your project loading the top level CMakeLists.txt in cpp_hello_world folder.  The 'io_world/io_world/generated/api/' folder contains all definitions of the enums and structs for your module, as well as the interface classes for your Interfaces. From now on you can simply include the header files for the api interface or the stub implementation and use it. For more details on generated features please check api, stubs.  tip Check our &quot;examples&quot; with all features enabled to get more working examples.  note For the simulation check the olink feature which provides middle layer on your code side and the simulation explained.  ","version":"Next","tagName":"h2"},{"title":"Create and run an example​","type":1,"pageTitle":"Quick-Start","url":"/template-cpp14/docs/quickstart#create-and-run-an-example","content":" Prepare an examples folder in the hello-world/cpp_hello_world directory with a main.cpp like this:  #include &quot;io_world/implementation/hello.h&quot; #include &lt;iostream&gt; int main(){ HelloWorldExample::IoWorld::Hello myHelloInstance; // Try out properties: subscribe for changes myHelloInstance._getPublisher().subscribeToLastChanged( [](const HelloWorldExample::IoWorld::Message&amp; last) { std::cout &lt;&lt; &quot;last property changed &quot;; }); // and ask for change. HelloWorldExample::IoWorld::Message messageForProperty; messageForProperty.m_content &quot;New message&quot;; myHelloInstance.setLast(messageForProperty); // Check the signals with subscribing for its change myHelloInstance._getPublisher().subscribeToJustSaid( [](const HelloWorldExample::IoWorld::Message&amp; msg) { qDebug() &lt;&lt; &quot;justSaid signal emitted &quot;; }); // and emit one. HelloWorldExample::IoWorld::Message messageForSignal; messageForSignal.m_content &quot;Message from signal&quot;; emit myHelloInstance.justSaid(messageForSignal); // Play around executing operations, maybe they emit signals? or change the properties? auto method_result = myHelloInstance.say(HelloWorldExample::IoWorld::Message(), HelloWorldExample::IoWorld::When::Now); return 0; }   add a CMakeLists.txt to the examples folder:  cmake_minimum_required(VERSION 3.1) project(MyExample) # append local binary directory for conan packages to be found list(APPEND CMAKE_MODULE_PATH ${CMAKE_BINARY_DIR}) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED ON) add_executable(MyExample main.cpp) # ensure maximum compiler support if(NOT MSVC) target_compile_options(app PRIVATE -Wall -Wextra -Wpedantic -Werror -fvisibility=hidden) else() target_compile_options(app PRIVATE /W4 /WX /wd4251) endif() find_package(io_world QUIET COMPONENTS io_world-core io_world-implementation ) target_link_libraries(app io_world::io_world-core io_world::io_world-implementation ) install(TARGETS app RUNTIME DESTINATION bin COMPONENT Runtime)   Add the examples subdirectory to the hello-world/cpp_hello_world/CMakeLists.txt. Now you can build the application and the libraries with it and run your example.  tip If generating all features, you'll need Poco library (websockets library used by OLink feature) or Paho (Mqtt library used by mqtt feature)'. You then may want to use conan feature, which will get all necessary dependencies. Otherwise you might want to addset(CMAKE_MODULE_PATH &quot;path/to/your/poco_or_paho_build&quot;) to your CMakeLists or use option -DCMAKE_PREFIX_PATH=$GITHUB_WORKSPACE/path/to/poco_or_paho_build . You might want also use conan for first time - to get you all those dependencies and then use paths provided by conan. ","version":"Next","tagName":"h3"},{"title":"Olink","type":0,"sectionRef":"#","url":"/template-cpp14/docs/features/olink","content":"","keywords":"","version":"Next"},{"title":"Apigear ObjectLink protocol and ObjectLink core library​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#apigear-objectlink-protocol-and-objectlink-core-library","content":" The ObjectLink protocol is a lightweight websocket based protocol for Objects described with an interface. It allows connecting a client object with a server object, and perform remote operations like: remote property change request (client) or notifications on property changed (server), inform about signal emission (server) and allows requesting a remote method call (client) and delivering a response to the caller (server).  The Olink feature for your interface uses a library ObjectLink core, common for cpp based templates. The provided CMakeLists already contain all the dependencies, so you don't have to add it manually.  The library provides an abstraction layer for handling the protocol, independent of the actual network stack. It encodes and decodes the messages and delivers them to corresponding objects identified by a registry. The setup is minimal: instantiate the registry (for client and/or server) and pass them to network layer objects in cpp apigear library  caution In this library we use STL classes in public interfaces. We assume that this library is built from source (configuration provided by generated CMakeLists). Otherwise, it has to be ensured that your build configuration matches the library build configuration.  ","version":"Next","tagName":"h3"},{"title":"File overview for module​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#file-overview-for-module","content":" With out example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂cpp_hello_world ┃ ┣ 📂apigear ┃ ┃ ┣ 📂mqtt ┃ ┃ ┣ 📂olink ┃ ┃ ┃ ┣ 📂private ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜olinkconnection.cpp ┃ ┃ ┃ ┣ 📜olinkconnection.h ┃ ┃ ┃ ┣ 📜olinkhost.cpp ┃ ┃ ┃ ┣ 📜olinkhost.h ┃ ┃ ┃ ┣ ... (helper files) ┃ ┃ ... ┃ ┣ 📂examples ┃ ┣ 📂modules ┃ ┃ ┗ 📂io_world ┃ ┃ ┃ ┣ 📂generated ┃ ┃ ┃ ┃ ┗ 📂olink ┃ ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┃ ┣ 📜helloclient.cpp ┃ ┃ ┃ ┃ ┃ ┣ 📜helloclient.h ┃ ┃ ┃ ┃ ┃ ┣ 📜helloservice.cpp ┃ ┃ ┃ ┃ ┃ ┗ 📜helloservice.h ┃ ┣ 📜 Lifecycle for olink client-server implementation.md ...   note You may notice an extra document: 📜Lifecycle for olink client-server implementation.md which explains life cycle of main objects used when using an olink protocol, in a form of flow diagrams.  ","version":"Next","tagName":"h2"},{"title":"cpp ApiGear - The Network Layer​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#cpp-apigear---the-network-layer","content":" When generating the olink feature (or monitor feature) you'll get an additional folder at the top most directory: the 📂hello-world/cpp_hello_world/apigear. The 📂olink subfolder contains objects that implement a network layer (based on Poco library) for the ObjectLink protocol. Those are:  OlinkClient - the client, that serves your interface client adapters. The class is responsible for network connection for ObjectLink client side. It uses the ObjectLink core library for handling messages according to the ObjectLink protocol. Handles linking and unlinking with a remote service for the sink added by the user (the interface OlinkClient Adapters), with regard to the connection state. All the messages dedicated to your object will be delivered to the adapter and proper actions will be performed for the clients that use it, without any of your actions. Also the OlinkClient holds a message queue for messages during disconnected time. OlinkHost and a helper class OlinkRemote that you'll find in 📂private subfolder The server, which hosts your services exposed to network through the interface server adapters. The class is responsible to set up the server and manage connections requested by clients. It uses ObjectLink core library for handling messages according to the ObjectLink protocol. All incoming messages will be translated to calls and routed to your local object.  ","version":"Next","tagName":"h3"},{"title":"Olink Client Adapter​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#olink-client-adapter","content":" Files 📜helloclient.h and 📜helloclient.cpp contain the olink client version of the Hello interface - an HelloClient class. It implements two interfaces: IHello and a IObjectSink.  IObjectSink (click to expand) class IObjectSink { public: virtual std::string olinkObjectName() = 0; virtual void olinkOnSignal(const std::string&amp; signalId, const nlohmann::json&amp; args) = 0; virtual void olinkOnPropertyChanged(const std::string&amp; propertyId, const nlohmann::json&amp; value) = 0; virtual void olinkOnInit(const std::string&amp; objectId, const nlohmann::json&amp; props, IClientNode* node) = 0; virtual void olinkOnRelease() = 0; };   The IObjectSink interface comes from ObjectLink core and is necessary for handling incoming messages from the server side and is used by a OLinkClient (cpp Apigear Olink lib). Apart from setting up and tear down of the OLinkHello object, you don't need to perform any additional actions, the object OLinkHello will communicate with the server transparently and you should use it as an IHello Object only.  Properties​  The property getters (here Message last() ) return immediately the locally stored last received value from server.  The property setter (here void setLast(const Message&amp; last) ) requests setting a value on server side, local value is not changed.  You can subscribe to a property changed (here last property ) through the publisher you can get from the HelloClient with _getPublisher(). Or you can subscribe (instead of the above) for as an IHelloSubscriber to receive all changes (and signals). When the client receives information that server changed the property, a target property (here last) is updated locally and a notifies subscribers that property has changed.  note The connected client has its local properties initialized - on a successful linking client with server the client receives a message with current state of properties of the service on server side.  Operations​  The operations have an additionally async version, which is called by the immediate version. The async version sends an invoke operation request to a server.  So calling myOlinkHelloInstance.say(myWhen) implements execution of sayAsync and waits for the result (for non-void type of operations). Have in mind that this is a blocking operation.  Signals​  You should not emit any signals from a client.  You can connect to any signals offered by your interface (here void justSaid(const Message&amp; msg) ), through the publisher. You can either select the signal you're interested in, or subscribe as an IHelloSubscriber to get all the signals and property change notifications.  When a HelloClient client receives the message from server that indicates the signal was emitted it emits a signal (here justSaid).  Use HelloClient​  As mentioned earlier you need a network layer, here provided by a ApiGear::ObjectLink::OLinkClient which also contains the protocol handling ClientNode. All you need to do is give it a global ApiGear::ObjectLink::ClientRegistry, request connecting to host when it is convenient for you and then add your HelloClient.  ApiGear::ObjectLink::ClientRegistry registry; ApiGear::ObjectLink::OLinkClient client(registry); // Create a global registry. ApiGear::ObjectLink::ClientRegistry registry; // Create a client and make a connection ApiGear::PocoImpl::OlinkConnection client(registry); // Create your client and request linking, which will try to connect with a server side for this object. auto ioWorldHello = std::make_shared&lt;IoWorld::olink::HelloClient&gt;(); client.connectAndLinkObject(ioWorldHello); client.connectToHost(Poco::URI(&quot;ws://localhost:8182&quot;)); // You can try out properties auto lastMessage = ioWorldHello-&gt;getLast(); // Executing the methods ioWorldHello-&gt;say(lastMessage, IoWorld::WhenEnum::Soon); IoWorld::Message someMessage(&quot;the new content&quot;); ioWorldHello-&gt;setLast(someMessage); // Or subscribe for signals. ioWorldHello-&gt;_getPublisher().subscribeToJustSaid([](auto args) { /*handle the signal*/}); // remember to unlink your object if you won't use it anymore. client.unlinkObjectSource(ioWorldHello-&gt;olinkObjectName());   caution ApiGear::ObjectLink::ClientRegistry can have only one object with the same identifier. This means that, to have more than one OlinkHello objects you would need to put them in different registries. Each Object has an identifier which is created based on the Interface Name, this way client object can be matched with proper server object.  ","version":"Next","tagName":"h3"},{"title":"Olink Server Adapter​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#olink-server-adapter","content":" Files 📜helloservice.h and 📜helloservice.h contain the olink server adapter for the Hello interface - the HelloService class.  It implements an IObjectSource interface (from ObjectLink core), which wraps your Hello and exposes it for remote usage with the ObjectLink protocol. It handles all the network requests, and calls your local object.  When creating the HelloService you need to provide the local IHello service object, you want to expose to clients.  The IObjectSource interface:  IObjectSource (click to expand) class IObjectSource { public: virtual std::string olinkObjectName() = 0; virtual nlohmann::json olinkInvoke(const std::string&amp; methodId, const nlohmann::json&amp; args) = 0; virtual void olinkSetProperty(const std::string&amp; propertyId, const nlohmann::json&amp; value) = 0; virtual void olinkLinked(const std::string&amp; objectId, IRemoteNode* node) = 0; virtual void olinkUnlinked(const std::string&amp; objectId) = 0; virtual nlohmann::json olinkCollectProperties() = 0; };   After setting up the OlinkHost (cpp Apigear Olink lib) and registering your Interface registered, the client connections and communication with them is handled transparently for you, no additional actions are needed.  note All the received messages from the clients are handled in a thread in which the connection resides, this means that your object may be used from different threads (local and each connection).  Properties​  Each time a property change signal (here void lastChanged(const Message&amp; last) ) is emitted, a message is sent to all connected clients. The message contains the information, which property changed and the corresponding value. This may occur either when you change a property directly on your local Hello object, or when a change property request message is received by the HelloService, which applies the property on your local Hello object.  Operations​  The remote operations invocation from the clients via the network will be performed on your local Hello object. The result of the operation (if any) will be returned only to the caller, not all clients. Have in mind that your object may be called from more that one thread.  Signals​  All the signals emitted by your local Hello objects are forwarded to all connected clients with an olink messages.  Use OLinkHelloAdapter​  As mentioned earlier you need a network layer, here provided by a ApiGear::ObjectLink::OLinkHost which also contains the protocol handling RemoteNodes. The ApiGear::ObjectLink::OLinkRemote objects are created automatically per connection. All you need to do is give a global ApiGear::ObjectLink::RemoteRegistry with your OLinkHelloAdapter in it to ApiGear::ObjectLink::OLinkHost.  ApiGear::ObjectLink::RemoteRegistry registry; auto logFunction = [](auto /*level*/, auto /*msg*/){ }; ApiGear::PocoImpl::OLinkHost testserver(registry,logFunction); auto ioWorldHello = std::make_shared&lt;IoWorld::Hello&gt;(); auto ioWorldOlinkHelloService = std::make_shared&lt;IoWorld::olink::HelloService&gt;(ioWorldHello, registry); registry.addSource(ioWorldOlinkHelloService); auto portNumber = 8000; testserver.listen(portNumber); // use your ioWorldHello as it was Hello implementation, all property changes, and signals will be passed to connected OLink clients. auto lastMessage = ioWorldHello-&gt;getLast(); ioWorldHello-&gt;say(lastMessage, IoWorld::WhenEnum::Soon); IoWorld::Message someMessage(&quot;the new content&quot;); ioWorldHello-&gt;setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value. testIoWorldHello-&gt;_getPublisher().publishJustSaid(someMessage); // remember to remove from registry if you won't use it anymore. registry.removeSource(ioWorldOlinkHelloService-&gt;olinkObjectName());   ","version":"Next","tagName":"h3"},{"title":"Simulation​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#simulation","content":" The simulation can be used to test, demonstrate or develop applications without the need to have the actual service available. The simulation server is integrated into the ApiGear studio and the CLI.  For simulating you will use simulation scenarios They allow to define sequences of actions. The actions can change the property values of the service or emit signals. The scenarios can be written using a YAML schema.  See more on simulation.  ","version":"Next","tagName":"h2"},{"title":"Prepare your application​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#prepare-your-application","content":" Make sure you are using OlinkClient as your Hello object, an instance on cpp side  You may try our example, it subscribes for signals and property changes, with a simple logging function. Create new folder under examples directory. Paste the below main.cpp and CMakeLists.txt files. Remember to add this directory to main CMakeLists.txt (or to extend test_conan.bat/sh in case using conan).  main.cpp (click to expand) #include &lt;iostream&gt; #include &quot;io_world/generated/olink/helloclient.h&quot; #include &quot;apigear/olink/olinkconnection.h&quot; #include &quot;apigear/tracer/tracer.h&quot; #include &quot;apigear/olink/olinklogadapter.h&quot; #include &quot;olink/clientregistry.h&quot; #include &quot;olink/clientnode.h&quot; #include &quot;apigear/olink/olinkconnection.h&quot; #include &lt;iostream&gt; using namespace HelloWorldExample; int main() { // Create a global registry. ApiGear::ObjectLink::ClientRegistry registry; // Create a client and make a connection ApiGear::PocoImpl::OlinkConnection client(registry); // Create your client and request linking, which will try to connect with a server side for this object. auto ioWorldHello = std::make_shared&lt;IoWorld::olink::HelloClient&gt;(); client.connectAndLinkObject(ioWorldHello); client.connectToHost(Poco::URI(&quot;ws://localhost:8182&quot;)); // Or subscribe for signals. ioWorldHello-&gt;_getPublisher().subscribeToJustSaid([](auto&amp; /*args*/) { std::cout &lt;&lt; &quot;Just said received&quot; &lt;&lt; std::endl; }); ioWorldHello-&gt;_getPublisher().subscribeToLastChanged([](auto&amp; /*args*/) { std::cout &lt;&lt; &quot;Last Changed&quot; &lt;&lt; std::endl; }); bool keepRunning = true; std::string cmd; do { std::cout &lt;&lt; &quot;Enter command:&quot; &lt;&lt; std::endl; getline(std::cin, cmd); if (cmd == &quot;quit&quot;) { keepRunning = false; client.disconnect(); } } while (keepRunning); client.disconnectAndUnlink(ioWorldHello-&gt;olinkObjectName()); return 0; }   CMAkeLists.txt (click to expand) cmake_minimum_required(VERSION 3.1) project(OLinkClientSimuExample) # append local binary directory for conan packages to be found list(APPEND CMAKE_MODULE_PATH ${CMAKE_BINARY_DIR}) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED ON) set (SOURCES main.cpp ) add_executable(OLinkClientSimuExample ${SOURCES} ) # ensure maximum compiler support if(NOT MSVC) target_compile_options(OLinkClientSimuExample PRIVATE -Wall -Wextra -Wpedantic -Werror -fvisibility=hidden) else() target_compile_options(OLinkClientSimuExample PRIVATE /W4 /WX /wd4251) # disable the warning for getenv - needs better cross platform solution target_compile_definitions(OLinkClientSimuExample PRIVATE -D_CRT_SECURE_NO_WARNINGS) endif() find_package(io_world QUIET COMPONENTS io_world-core io_world-implementation io_world-monitor io_world-olink) target_link_libraries(OLinkClientSimuExample io_world::io_world-core io_world::io_world-implementation io_world::io_world-monitor io_world::io_world-olink ) install(TARGETS OLinkClientSimuExample RUNTIME DESTINATION bin COMPONENT Runtime)   note Make sure to configure the client to use the correct IP and port configuration of your simulation server e.g. set client.connectToHost(QUrl(&quot;ws://127.0.0.1:8182/ws&quot;)); and make sure your apigear simulation also uses this port.  ","version":"Next","tagName":"h3"},{"title":"Prepare the scenario​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#prepare-the-scenario","content":" As a starting point you can check our simulation scenario:  Scenario(click to expand) schema: apigear.scenario/1.0 name: &quot;first scenario&quot; version: &quot;1.0.0&quot; #initial properties and setting gunction response interfaces: - name: io.world.Hello #( module io.world and interface Hello combination) properties: last: {content: &quot;Initial&quot;} operations: - name: say actions: - $return: { value: 88 } # sequence of changing properties and emitting signals sequences: - name: play with hello interval: 2000 # 2 seconds interface: io.world.Hello loops: 3 steps: # step is called every 2 secs according to interval - name: change property actions: - $set: { last: {content: &quot;First Change of Property&quot;} } - name: emit signal actions: - $signal: { justSaid: [ {content: &quot;First Message&quot;} ] } - name: change property AND emit signal actions: - $set: { last: {content: &quot;Second Change of Property&quot;} } - $signal: { justSaid: [ {content: &quot;Other Signal&quot;} ] }   Apart from the header with the scenario name and its version it consists of two parts:  initialization for each interface (here, our ui.world.Hello line 6), we're setting initial values of properties(line 8) and the return value of function calls (line 12) sequence of events You can prepare more than one sequence. For each of them set interval between calling each action (line 16), set how many runs of that sequence you want to execute (line 18) and name the interface the action should be applied to (line 17). In each action you may change many properties, and emit signals.  ","version":"Next","tagName":"h3"},{"title":"Run the simulation​","type":1,"pageTitle":"Olink","url":"/template-cpp14/docs/features/olink#run-the-simulation","content":" Put your scenario file in the 📂hello-world/apigear along with other .yaml files.  If you are using the studio, reload your project. Go to settings and make sure to set same the port as in your client app (here 8182). Click the play button in the application in the simulation tab to start the simulation scenario, then start the client application.  Instead of the ApiGear Studio application can also use its console version, run your scenario with command:  apigear simulate run path-from-cli-to-scenario/helloworldtest.scenario.yaml --addr :8182   note We tried some measurements for the OLink performance. You may want to check the our tests here. We're not providing any data of throughput and latency, as the branch is still in between alpha phase. In general we expect it to be fast as it has small overhead (which may be not sufficient for you). ","version":"Next","tagName":"h3"},{"title":"Template Python","type":0,"sectionRef":"#","url":"/template-python/docs/intro","content":"Template Python This is the documentation for the Python template. It is split in these parts: Quick-Start is the easiest way to get startedFeatures explains the available code generator features, including what code is generated and why","keywords":"","version":"Next"},{"title":"MQTT","type":0,"sectionRef":"#","url":"/template-python/docs/features/mqtt","content":"","keywords":"","version":"Next"},{"title":"Before Start​","type":1,"pageTitle":"MQTT","url":"/template-python/docs/features/mqtt#before-start","content":" The mqtt library needs to be installed separately, make sure you have installed all the libraries listed in requirements  `pip install --upgrade -r requirements.txt`   ","version":"Next","tagName":"h3"},{"title":"File overview for module​","type":1,"pageTitle":"MQTT","url":"/template-python/docs/features/mqtt#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂py_hello_world ┃ ┣ 📂apigear ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┣ 📜base.py ┃ ┃ ┃ ┣ 📜client.py ┃ ┃ ┃ ┣ 📜service.py ┃ ┃ ┃ ┗ 📜__init__.py ┃ ┃ ┃ ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂impl ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┣ 📜sinks.py ┃ ┃ ┃ ┣ 📜sources.py ┃ ┃ ┃ ┗ 📜__init__.py ...   ","version":"Next","tagName":"h2"},{"title":"Python apigear - The Network Layer​","type":1,"pageTitle":"MQTT","url":"/template-python/docs/features/mqtt#python-apigear---the-network-layer","content":" When generating the mqtt feature (or any of those: olink monitor feature) you'll get an additional folder it the top most directory: the 📂hello-world/📂apigear. The 📂mqtt subfolder contains objects that implement a network layer (based on Paho Mqtt library) for the MQTT protocol. Those are:  Client - Adapts the MQTT client, to serve as an network endpoint for interface client adapters. Exposes: methods that allow receiving data for remote service: subscribing for properties changes, signals emission and method response invocation;methods that allow remote using the service: requesting property change or invoking a method. The client may serve many client interface adapters, even for the same interfaces (allows subscribing for same topic). In case many interface client adapters for same interface are connected: property changes and signals are provided to all interface client adapters, but the invoke method response will be delivered only for the one that requested it. Service - Adapts the MQTT client to serve as an network endpoint for interface service adapters. Exposes: methods that allow receiving requests from remote clients: subscribing for properties change requests, send method invocation;methods that allow publishing property change, signal, functionality to handles sending a response for method invocation requests. This Service may be used for many, interface service adapters, but it is not recommended to use more than one interface service adapter for the same interfaces.  tip Have in mind that MQTT might not be suitable for high-frequency messages especially with one mqtt client serving more than one object. Also the brokers have limits for messages number/size queued from one client. In case you are not getting all the messages consider changing those or splitting traffic between more clients (maybe some handle the properties, some handle the methods).  ","version":"Next","tagName":"h3"},{"title":"MQTT Client Adapter​","type":1,"pageTitle":"MQTT","url":"/template-python/docs/features/mqtt#mqtt-client-adapter","content":" File 📜sinks.py contains the remote client for the Hello interface - a HelloClientAdapter class. The object is an IHello implementation. It requires an instance of Apigear::Mqtt::Client to work. It uses the Client to subscribe (and unsubscribe) for topics that allow receiving properties, signals and invoke responses from service.  Properties​  The property getters (here getter get_last) return immediately the locally stored last received value from server. The property setter (here setter set_last ) requests setting a value on server side, local value is not changed. You can add handler for a property changed event (here on_last_changed(Message) ) When the client receives information that server changed the property, a target property (here last) is updated locally and all handlers added for the event are fired (in addition order) with the new value of property.  note The connected interface client adapter has its local properties in sync with a service. The properties messages are retained in mqtt broker, so all already set properties are provided.  Operations​  The operations are async, and they return a coroutine awaited with a timeout of 500 seconds. The async method sends an invoke operation request to a service and waits for the response. Have in mind that this is a blocking operation.  Signals​  You should not emit any signals from a client. You can add a handler to any signals offered by your interface (here void just_said(Message) ) When a HelloClientAdapter client receives the message from server that indicates the signal was emitted it executes all added handlers to a on_just_said event hook.  Use HelloClientAdapter​  HelloClientAdapter is an adapter of you interface to the Mqtt Client (with protocol and network layer implementation), here provided by a apigear.mqtt.Client. All you need to do is to pass the apigear.mqtt.Client to your Interface Client Adapter, and request connecting to host when it is convenient for you. You can find the example code for the your Hello MQTT client below. Remember to run a MQTT broker of your choice.  import os import sys # add context - your relative path from this example to py_hello_world dir e.g. like this sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../'))) import apigear.mqtt import logging import io_world.mqtt import io_world.api async def main(): # create a mqtt adapter for client side client = apigear.mqtt.Client(&quot;UniqueClientNameForMqttHelloExample&quot;) # create mqtt interface adapters for client side mqtt_hello = io_world.mqtt.HelloClientAdapter(client) await client.connect(&quot;localhost&quot;, 1883) # Subscribe for property changes def handleProperty(value): print(&quot;received property change&quot;); print(value); mqtt_hello.on_last_changed += handleProperty # or ask for change. local_last = io_world.api.Message(); local_last.content = &quot;New message&quot; mqtt_hello.set_last(local_last); # Check the signals with subscribing for its change def handleSignal(value): print(&quot;received signal&quot;); print(value); mqtt_hello.on_just_said += handleSignal # Play around executing your operations message_to_say = io_world.api.Message() message_to_say.content = &quot;Message to say&quot; result = mqtt_hello.say(message_to_say, io_world.api.When.NOW) await result print(&quot;method result&quot;) print(result) input(&quot;Press Enter to close&quot;) client.disconnect() if __name__ == '__main__': loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.run_until_complete(main())   ","version":"Next","tagName":"h3"},{"title":"MQTT Server Adapter​","type":1,"pageTitle":"MQTT","url":"/template-python/docs/features/mqtt#mqtt-server-adapter","content":" File 📜sources.py contains the mqtt server side adapter for the Hello interface - the HelloServiceAdapter object. When creating the HelloServiceAdapter you need to provide the apigear.mqtt.Service and the local implementation of IHello, local service. HelloServiceAdapter object exposes the local object for remote usage with the MQTT protocol. It handles all the network requests, and calls your local object. The mqtt client connection and communication is handled transparently, no additional actions are needed.  Properties​  The MQTT service adapters add handlers for all the properties changes to the local implementation. On property change the generated implementation executes all added handlers. In this example on each last property change the handler for on_last_changed(Message), sends a message with a topic specific for this property in this interface and with value in the payload. This happens either when you change a property directly on your local Hello object, or when a change property request message is received by the HelloServiceAdapter, which applies the property on your local Hello object.  Operations​  The operations invocation which came from the clients through the network will be performed on your local Hello object. The result of the operation (if any) will be returned only to a client, from which the message was send, not all clients.  Signals​  The MQTT service adapters add handlers for all the signals to the local implementation which send MQTT messages with information about signal emission with their arguments. On signal emission the generated implementation executes all handlers added for this signal. All the signals emitted by your local Hello objects are forwarded to all connected clients.  Use HelloServiceAdapter​  HelloServiceAdapter an adapter of your interface to the specific, object server side, version of Mqtt Client (with protcol and network layer implementation), here provided by a ApiGear::Mqtt::ServiceAdapterAll you need to do is to pass this ServiceAdapter to your Interface Service Adapter, and request connecting to host when it is convenient for you. You can find the example code for the your Hello MQTT service below. Remember to run a MQTT broker of your choice.  import os import sys # add context - your relative path from this example to py_hello_world dir e.g. like this sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../'))) import apigear.mqtt import io_world.impl import io_world.mqtt import io_world.api async def main(): service = apigear.mqtt.Service(&quot;uniqueServiceIdForHelloService&quot;) source_io_world_hello = io_world.impl.Hello() serviceAdapter_io_world_hello = io_world.mqtt.HelloServiceAdapter(source_io_world_hello, service) await service.connect(&quot;localhost&quot;, 1883) # Set property, the change will be sent to all clients, and local handlers if any. local_last = io_world.api.Message(); local_last = &quot;New message from server&quot; source_io_world_hello.set_last(local_last); # Emit the signal, it will be sent to all clients signal_message = io_world.api.Message() signal_message = &quot;New message from server&quot; source_io_world_hello._just_said(signal_message) input(&quot;Press Enter to close&quot;) service.disconnect() if __name__ == '__main__': loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) loop.run_until_complete(main())   note The implemented Mqtt Client (used both in apigear.mqtt.Client and apigear.mqtt.Service ) uses a thread to process network traffic. This mean, if you're having an asynchronous application, that reacting on the events inside you handlers (for all: properties, signals, operation results) may require usingloop.call_soon_threadsafe(callback, *args) to handle the output in your main event loop.  ","version":"Next","tagName":"h3"},{"title":"MQTT Messages​","type":1,"pageTitle":"MQTT","url":"/template-python/docs/features/mqtt#mqtt-messages","content":" In case you want construct messages for client or server side on your own, please check how topics are created and how does the payload look like, check this documentS messages format. ","version":"Next","tagName":"h3"},{"title":"Quick-Start","type":0,"sectionRef":"#","url":"/template-python/docs/quickstart","content":"","keywords":"","version":"Next"},{"title":"1. Install the code generator​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#1-install-the-code-generator","content":" Get the ApiGear Studio or ApiGear CLI. For more information check the ApiGear documentation.  ","version":"Next","tagName":"h2"},{"title":"2. Get the template​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#2-get-the-template","content":" There are several options to get the template. Installation via the Studio or the CLI. Alternatively it is possible to clone or download from github.  ","version":"Next","tagName":"h2"},{"title":"Installation via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#installation-via-cli","content":" When using the CLI only the highlighted line is imported. You can always check whether the installation was successful via the template list command.  $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-python | false | true | https://github.com/apigear-io/template-python.git ... $ apigear template install apigear-io/template-python $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-python | true | true | https://github.com/apigear-io/template-python.git ...   ","version":"Next","tagName":"h3"},{"title":"Installation via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#installation-via-studio","content":" From within the studio the installation is really simple.  Open an existing project or create an new oneGo to the Templates tabClick Install on the apigear-io/template-python entry  ","version":"Next","tagName":"h3"},{"title":"Clone from github​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#clone-from-github","content":" In case you want to check or modify the source code of the template, it is easier to clone or download the repository. The repository does not need to be part of the project, but can be stored anywhere on the computer.  $ git clone https://github.com/apigear-io/template-python.git   ","version":"Next","tagName":"h3"},{"title":"3. Set up project​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#3-set-up-project","content":" For a project we usually need two files. The solution which specifies what APIs and which template to use for it. And at least one API module file. Both should ideally be in a folder called apigear next to each other.  Alternatively, you can also use the Studio to create a new project and modify the two example files.  ","version":"Next","tagName":"h2"},{"title":"Solution file​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#solution-file","content":" Create a solution file. The example below specifies  module files in line 8, here the helloworld.module.yaml module with Hello APIthe output directory for generated files in line 9a template used to generate the code in line 10, here the apigear-ui/template-python template. This can also be a path to a local copy of the template.the enabled features of the template in line 13, here the stubs feature, a simple implementation of interfaces. For all available features check the overview.  helloworld.solution.yaml schema: &quot;apigear.solution/1.0&quot; name: hello_world_example version: &quot;0.1.0&quot; targets: - name: hello_world inputs: - helloworld.module.yaml output: ../py_hello_world template: apigear-io/template-python force: true features: - stubs   Targets You can extend this solution file with other targets, each for the different technology with different template. The module.yaml is technology independent and may be used for any template.  note Set the force parameter to true if you want to always override all the generated files. With option set to false some files, like implementation (stub feature) won't be updated. All the API files are always updated.  ","version":"Next","tagName":"h3"},{"title":"API module file​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#api-module-file","content":" Use your favorite text editor to create the helloworld.module.yaml with the example content:  helloworld.module.yaml schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"4. Generate code​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#4-generate-code","content":" With the output directory set as in example, both ApiGear files reside in an apigear subfolder next to the generated files. In this case the folder structure should look similar to this  📂hello-world ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂py_hello_world ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┗ 📂implementation ┃ ┗ 📜CMakeLists.txt   Using the solution file from the previous paragraph the code will be generated in the py_hello_world folder. With subfolder for each module, here io_world as the name of module (defined in line 2 of helloworld.module.yaml). It contains both features generated: a basic api and a stub implementation.  ","version":"Next","tagName":"h2"},{"title":"Generate via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#generate-via-cli","content":" The following snippet shows how the CLI can be run.  $ apigear generate solution apigear/helloworld.solution.yaml 10:52:20 INF generated 38 files in 65ms. (22 write, 0 skip, 16 copy) topic=gen   generate tells the CLI that it should generate codesolution specifies that we want to run a solution file  ","version":"Next","tagName":"h3"},{"title":"Generate via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#generate-via-studio","content":" Open the projectGo to the Solutions tabClick Run on the helloworld.solution.yaml entry  ","version":"Next","tagName":"h3"},{"title":"5. Use the generated Python project.​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#5-use-the-generated-python-project","content":" note Make sure you have Python in at least 3.11 version and pip package installer for python.  The generated code provides Python implementations. The following paragraphs show how you can use it. Start with installing all the requirements in requirements.txt file in top level directory with commandpip install --upgrade -r requirements.txt  tip It is recommended to install the dependencies in a virtual environment(venv).  The 'api.py' contains all definitions of the enums and structs for your module, as well as the abstract base classes for your Interfaces. From now on you can simply import the api or the stub implementation modules and use it. For more details on generated features please check api(TBD), stubs (TBD).  tip Check the extended features to see how to use your API over the network.  note For the simulation check the olink feature(TBD) which provides middle layer on your code side and the simulation explained.  ","version":"Next","tagName":"h2"},{"title":"Create and run an example​","type":1,"pageTitle":"Quick-Start","url":"/template-python/docs/quickstart#create-and-run-an-example","content":" Prepare an examples folder in the hello-world/py_hello_world directory with a main. like this:  import asyncio import os import sys #add context - path to modules sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../'))) import io_world.api import io_world.impl def main(): myHelloInstance = io_world.impl.Hello() # Try out properties: subscribe for changes def handle_last_changed(message): print(&quot;last property changed &quot;) print(message) myHelloInstance.on_last_changed += handle_last_changed # and ask for change. messageForProperty = io_world.api.Message() messageForProperty.content = &quot;New message&quot;; myHelloInstance.set_last(messageForProperty); # Check the signals with subscribing for its change def handle_just_said(message): print(&quot;justSaid signal emitted &quot;) print(message) myHelloInstance.on_just_said += handle_just_said # and emit one. messageForSignal = io_world.api.Message() messageForSignal.content = &quot;Message from signal&quot;; myHelloInstance._just_said(messageForSignal); # Play around executing operations, maybe they emit signals? or change the properties? method_result = myHelloInstance.say(io_world.api.Message(), io_world.api.When.NOW); print(&quot;Method result&quot;) print(method_result) myHelloInstance.on_last_changed -= handle_last_changed myHelloInstance.on_just_said -= handle_just_said if __name__ == '__main__': main() }   You can run it e.g from console. Open a terminal, navigate to generated code (py_hello_world) and run the example with command python examples/example.py. ","version":"Next","tagName":"h3"},{"title":"API","type":0,"sectionRef":"#","url":"/template-qt6/docs/features/api","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"API","url":"/template-qt6/docs/features/api#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┃ ┣ 📜api.cpp ┃ ┃ ┃ ┣ 📜api.h ┃ ┃ ┃ ┣ 📜iapifactory.h ┃ ┃ ┃ ┣ 📜json.adapter.h ┃ ┃ ┃ ┗ 📜CMakeLists.txt ...   ","version":"Next","tagName":"h3"},{"title":"Api​","type":1,"pageTitle":"API","url":"/template-qt6/docs/features/api#api-1","content":" Files 📜api.h and 📜api.cpp contain the api: interfaces, data structures and enums.  Enums​  Each enum is exposed to qml and their metatype is declared with Q_DECLARE_METATYPE. For convenience of use each enum has:  toEnum function converts given quint8 to enum value.QDataSteram in and out operators for the enum.  Structs​  Each struct has its fields exposed for qml  api.h ... struct IO_WORLD_API_EXPORT Message { Q_GADGET Q_PROPERTY(QString content MEMBER m_content ) ...   note We generate the import/export statements (here IO_WORLD_API_EXPORT) for all the classes and structs that have an implementation in a cpp file and may be used outside of the library.  For convenience of use each structure has:  equality comparison operatorsthe QDataSteram in and out operators for the generated struct Message.  The struct metatype is declared with Q_DECLARE_METATYPE. That may not be enough if you want to bind to fields of the struct in qml. In that case we suggest using a plugin which provides factory for it.  Interfaces​  Base interface version for Qt template is a QObject Abstract base class, here AbstractHello. It contains:  a pure virtual getters and a setters for each property   virtual void setLast(const Message&amp; last) = 0; virtual Message last() const = 0;   pure virtual functions for each operation  virtual int say(const Message&amp; msg, When::WhenEnum when) = 0;   signals: for each api signal and for each api property - on property changed signal  signals: void justSaid(const Message&amp; msg); void lastChanged(const Message&amp; last);   ","version":"Next","tagName":"h3"},{"title":"Other​","type":1,"pageTitle":"API","url":"/template-qt6/docs/features/api#other","content":" 📜 CMakeLists.txt for building this module, describing it's dependencies, and exposing built package for other features that will use it.📜 json.adapter.h prepares adapters for structs to easy read from or write to nlohmann::json  Message message = json.get&lt;Message&gt;(); nlohmann::json message = message;   📜iapifactory.h provides an interface for ApiFactory which can produce your interface instances, here the AbstractHello instance. It's purpose is to provide the chosen implementation to a QML wrappers. The factory main implementation is provided by the qmlplugin, which explains its purpose and usage in details. You can also find implementation of factory interface in stubs, monitor and olink features. They all allow creating different AbstractHello backend for QML wrapper. ","version":"Next","tagName":"h3"},{"title":"Features","type":0,"sectionRef":"#","url":"/template-qt6/docs/features","content":"","keywords":"","version":"Next"},{"title":"Get started​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#get-started","content":" This template generates code for Qt projects. In order to successfully compile and use the code, you need to have the Qt Engine installed (at least 5.12). Check the Qt website for your options for open-source or commercial version. Basic understanding of Qt is required, and depending on your goal the qml or c++ knowledge is also necessary.  ","version":"Next","tagName":"h2"},{"title":"Code generation​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#code-generation","content":" Follow the documentation for the code generation in general and CLI or the Studio tools. Or try first the quick start guide which shows how to prepare api and generate code out of it.  tip For questions regarding this template please go to our discussions page. For feature requests or bug reports please use the issue tracker.  ","version":"Next","tagName":"h3"},{"title":"Example API​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#example-api","content":" The following code snippet contains the API which is used throughout this guide to demonstrate the generated code and its usage in Qt.  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"Features​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#features-1","content":" ","version":"Next","tagName":"h2"},{"title":"Core​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#core","content":" Features generate a view model for the api. This can be used to implement a working C++ and qml service and directly use it in your UI project.  api - generates compilable abstract base interface and a basic implementation for data typesstubs - adds a basic stubs for the api, you'll get classes that can actually be instantiatedqmlplugin - generates plugin which can be used to add the qml types  ","version":"Next","tagName":"h3"},{"title":"Extended​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#extended","content":" Features can be used in combination with api and add more functionality on top, like the simulation  olink - provides a client and server adapters for each interface, that can be connected to any of the other technology templates with support for ObjectLink. Use this feature to connect with ApiGear simulation tools.monitor - generates a middleware layer which logs all API events to the CLI or the StudioMQTT experimental - provides minimal working adapters for MQTT client and service side for each interfaces. Check also MQTT in other technology templates that supports it.examples feature - generates: olinkserver example with main.cpp that shows your services in olink server.olinkclient example with main.cpp that shows your interfaces as olink client.qml example with a main.cpp and qmlmain.qml. The qml uses your interfaces. The main cpp sets olink client factory as a backend for the qml and sets up the olink server with your services (normally you'd have separate app for server)'.  Figure: Features overview, including receiving data from network: Bottom floor shows possible inputs for your API, you can either obtain data from the network with OLink or MQTT or use local implementation. The top floor shows feature qmlpugin for qml oriented applications.  Figure: Features overview, including publishing data through network: Topmost floor shows your options for using your local implementation (bottom floor): you can use it in your local app and/or use method of sharing the data with clients in the network.  tip You may also use the OLink/Mqtt service side with Qml, you just need to provide implementation of IApiFactory, which will allow OLink/Mqtt Services Adapters use the network endpoints and the services implementation.  There is also an internal feature apigear, which is generated for the extended features and is explained with them. Each feature can be selected using the solution file or via command line tool.  note *Features are case sensitive, make sure to always use lower-case. *  tip The meta feature all enables all specified features of the template. If you want to see the full extent of the generated code all is easiest solution. Please note, all is part of the code generator and not explicitly used within templates.  ","version":"Next","tagName":"h3"},{"title":"Folder structure​","type":1,"pageTitle":"Features","url":"/template-qt6/docs/features#folder-structure","content":" This graph shows the full folder structure which is generated for all features enabled. Generated features are encapsulated in separate folders inside the module folder, here io_world or for the common features like examples and the internal helper feature apigear, a level above, in the generation layer level, here qt_hello_world. For more details visit the documentation for each feature. A thirdparty folder is contains Qt Promise (up to 5.x.x Qt version).  📂hello-world ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┃ ┣ 📂olinkclient ┃ ┃ ┣ 📂olinkserver ┃ ┃ ┣ 📂qml ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂implementation ┃ ┃ ┣ 📂monitor ┃ ┃ ┣ 📂olink ┃ ┃ ┗ 📂plugin ┃ ┣ 📂thirdparty ┃ ┗ 📜CMakeLists.txt  ","version":"Next","tagName":"h2"},{"title":"Monitor","type":0,"sectionRef":"#","url":"/template-qt6/docs/features/monitor","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"Monitor","url":"/template-qt6/docs/features/monitor#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┃ ┣ 📂monitor ┃ ┃ ┃ ┣ 📜agentclient.cpp ┃ ┃ ┃ ┣ 📜agentclient.h ┃ ┃ ┃ ┗ 📜CMakeLists.txt ┃ ┃ ... ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂implementation ┃ ┃ ┣ 📂olink ┃ ┃ ┣ 📂monitor ┃ ┃ ┃ ┣ 📜agent.cpp ┃ ┃ ┃ ┣ 📜agent.h ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜tracedapifactory.cpp ┃ ┃ ┃ ┣ 📜tracedapifactory.h ┃ ┃ ┃ ┣ 📜hellotraced.cpp ┃ ┃ ┃ ┗ 📜hellotraced.h ...   ","version":"Next","tagName":"h2"},{"title":"Qt Trace Client​","type":1,"pageTitle":"Monitor","url":"/template-qt6/docs/features/monitor#qt-trace-client","content":" When generating the monitor feature (or olink feature) you'll get an additional folder it the top most directory: 📂hello-world/📂apigear. The 📂monitor subfolder contains a client for logging, with a network layer (based on the QtWebSocket library). The class connects to the Apigear Trace Server and takes care of formatting and sending the traces.  ","version":"Next","tagName":"h3"},{"title":"Monitor​","type":1,"pageTitle":"Monitor","url":"/template-qt6/docs/features/monitor#monitor-1","content":" Files 📜hellotraced.h and 📜hellotraced.cpp contain the trace wrapper for the Hello interface. The wrapper class is generated for each interface.  class IO_WORLD_MONITOR_EXPORT HelloTraced : public AbstractHello { explicit HelloTraced(std::shared_ptr&lt;AbstractHello&gt; impl); ... };   It shares the ownership of the wrapped object. It forwards all calls to the implementation and forwards all the signals (including the property changed signals) calls from it, so you can use the TracedHello as a Hello object. Note that the Hello object is the object that fulfills the AbstractHello interface, it can be e.g. the OlinkClient version of Hello.  The 📜agent.h and 📜agent.cpp files contain helpers to prepare interface specific trace data for the general tracing TraceClient  ","version":"Next","tagName":"h3"},{"title":"Tracing with QML objects​","type":1,"pageTitle":"Monitor","url":"/template-qt6/docs/features/monitor#tracing-with-qml-objects","content":" Files 📜tracedapifactory.h and 📜tracedapifactory.cpp contain the TracedApiFactory which creates the interfaces wrapped with the trace decorator. In our example it will produce only Hello interfaces:  class IO_WORLD_MONITOR_EXPORT TracedApiFactory : public QObject, public IApiFactory { TracedApiFactory(IApiFactory&amp; factory, QObject *parent = nullptr);   The factory is necessary when you want to use the traced Hello object directly in QML. For that, you will choose the QML version of your API to which you need provide proper backend - this is what the factory is for. See more details on providing backend to QML wrapper. The important difference between other factories implementations is, that the TracedHello is a wrapper, it requires the actual implementation to be passed to it. Therefor the factory needs a factory of the actual implementation objects, which it will wrap with the trace functionality. That it requires a factory in constructor. You can provide any backed you need e.g. your custom object, the OlinkClient. See the example of traced OlinkClient backend below:   // Prepare Factory before app is created. ApiGear::ObjectLink::ClientRegistry client_registry; ApiGear::ObjectLink::OLinkClient client(client_registry); io_world::OLinkFactory io_worldOlinkFactory(client); io_world::TracedApiFactory io_worldTracedOlinkFactory(io_worldOlinkFactory); io_world::ApiFactory::set(&amp;io_worldTracedOlinkFactory); ... // Connect the client - all qml olink clients will be linked if the server services are already up. client.connectToHost(QUrl(&quot;ws://127.0.0.1:8182&quot;));   The factory uses the ApiGear::ObjectLink::OLinkClient and links the objects when they are created. You don't have to perform any other actions, just use your qml version of Hello. Also on trace the TracedHello calls the AgentClient monitor class that handles connection to trace server. So with such setup you'll be able to get your data from OlinkServer and see the traces in ApiGear studio.  ... import io_world 1.0 ApplicationWindow { ... Button { width: 80 height: 80 text: qmlIoWorldHello.last.content onClicked: { qmlIoWorldHello.say(someMessage, someWhen) } } IoWorldHello { id: qmlIoWorldHello } ... }   ","version":"Next","tagName":"h3"},{"title":"Setup​","type":1,"pageTitle":"Monitor","url":"/template-qt6/docs/features/monitor#setup","content":" This feature requires using the classes wrapped with monitor decorators, which collect the traces, instead of using the implementation classes directly. Either in qml as shown above or in your code, where you create the interface instances.   #include &quot;io_world/implementation/hello.h&quot; #include &quot;io_world/monitor/hellotraced.h&quot; #include &lt;QtCore&gt; #include &lt;memory&gt; #include &lt;iostream&gt; int main(){ auto ioWorldHello = std::make_shared&lt;io_world::Hello&gt;(); io_world::HelloTraced ioWorldHelloTraced(ioWorldHello); useIoWorldHEllo(ioWorldHelloTraced); // your code that requires io_world::Hello }   Also make sure that you are using the same port for sending and receiving traces. For sending: check the apigear monitor agent agentclient.cpp, by default the address is set to ws://localhost:8152/ws. For receiver: go to studio settings and set same port number. ","version":"Next","tagName":"h3"},{"title":"MQTT","type":0,"sectionRef":"#","url":"/template-qt6/docs/features/mqtt","content":"","keywords":"","version":"Next"},{"title":"Before Start - prepare QMqtt Module​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#before-start---prepare-qmqtt-module","content":" The mqtt library is not a part of standard Qt build. You need to install this module on your own, you can find it here. Once you get the repository we recommend to build it with relWithDebug options e.g. like that  cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -DCMAKE_CXX_FLAGS_DEBUG=&quot;-O2&quot; . cmake --build . --config RelWithDebInfo cmake --install . --verbose   ","version":"Next","tagName":"h3"},{"title":"File overview for module​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┃ ┣ 📂monitor ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜mqttclient.cpp ┃ ┃ ┃ ┣ 📜mqttclient.h ┃ ┃ ┃ ┣ 📜mqttservice.cpp ┃ ┃ ┃ ┣ 📜mqttservice.h ┃ ┃ ┃ ┣ ... (helper files) ┃ ┃ ... ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂implementation ┃ ┃ ┣ 📂monitor ┃ ┃ ┣ 📂mqtt ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜mqtt_common.h ┃ ┃ ┃ ┣ 📜mqttfactory.cpp ┃ ┃ ┃ ┣ 📜mqttfactory.h ┃ ┃ ┃ ┣ 📜mqtthello.cpp ┃ ┃ ┃ ┣ 📜mqtthello.h ┃ ┃ ┃ ┣ 📜mqtthelloadapter.cpp ┃ ┃ ┃ ┗ 📜mqtthelloadapter.h ...   ","version":"Next","tagName":"h2"},{"title":"Qt apigear - The Network Layer​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#qt-apigear---the-network-layer","content":" When generating the mqtt feature (or any of those: olink monitor feature) you'll get an additional folder it the top most directory: the 📂hello-world/📂apigear. The 📂mqtt subfolder contains objects that implement a network layer (based on Qt Mqtt library) for the MQTT protocol. Those are:  Client - Adapts the Qt MQTT client, to serve as an network endpoint for interface client adapters. Exposes: methods that allow receiving data for remote service: subscribing for properties changes, signals emission and method response invocation;methods that allow remote using the service: requesting property change or invoking a method. The client may serve many client interface adapters, even for the same interfaces (allows subscribing for same topic). In case many interface client adapters for same interface are connected: property changes and signals are provided to all interface client adapters, but the invoke method response will be delivered only for the one that requested it. ServiceAdapter - Adapts the Qt MQTT client to serve as an network endpoint for interface service adapters. Exposes: methods that allow receiving requests from remote clients: subscribing for properties change requests, send method invocation;methods that allow publishing property change, signal, functionality to handles sending a response for method invocation requests. This ServiceAdapter may be used for many, interface service adapters, but it is not recommended to use more than one interface service adapter for the same interfaces.  tip Have in mind that MQTT might not be suitable for high-frequency messages especially with one mqtt client serving more than one object. Also the brokers have limits for messages number/size queued from one client. In case you are not getting all the messages consider changing those or splitting traffic between more clients (maybe some handle the properties, some handle the methods).  ","version":"Next","tagName":"h3"},{"title":"MQTT Client Adapter​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#mqtt-client-adapter","content":" Files 📜mqtthello.h and 📜mqtthello.cpp implement the remote client for the Hello interface - a MqttHello class. The object is an AbstractHello implementation. It requires an instance of Apigear::Mqtt::Client to work. It uses the Client to subscribe (and unsubscribe) for topics that allow receiving properties, signals and invoke responses from service.  Properties​  The property getters (here getter last) return immediately the locally stored last received value from server. The property setter (here setter setLast ) requests setting a value on server side, local value is not changed. &lt;br /&gt; You can connect to a property changed signals (here void lastChanged(const Message&amp; last)) When the client receives information that server changed the property, a target property (herelast) is updated locally and a signal that property has changed is emitted ( here void lastChanged(const Message&amp; last)`.  note The connected interface client adapter has its local properties in sync with a service. The properties messages are retained in mqtt broker, so all already set properties are provided.  Operations​  The operations have additionally the async version, which is called by the immediate version. The async version sends an invoke operation request to a server. So calling myMqttHelloInstance.say(myWhen) implements execution of sayAsync and waits for the result (for non-void type of operations). Have in mind that this is a blocking operation.  Signals​  You should not emit any signals from a client. You can connect to any signals offered by your interface (here void justSaid(const Message&amp; msg) ) When a MqttHello client receives the message from server that indicates the signal was emitted it emits a signal (here justSaid).  Use MqttHello​  MqttHello is an adapter of QtMqtt (with protcol and network layer implementation), here provided by a ApiGear::Mqtt::Client. All you need to do is to pass the ApiGear::Mqtt::Client to your Interface Client Adapter, and request connecting to host when it is convenient for you.   // Create a client and make a connection ApiGear::Mqtt::Client client(&quot;UniqueClientName&quot;); client.connectToHost(&quot;localhost&quot;, 1883); // Use the same port number as your broker is using. Typically, without any other settings it is &quot;1883&quot;. // Create your service client. auto ioWorldHello = std::make_shared&lt;io_world::MqttHello&gt;(client); // use your ioWorldHello as it was Hello implementation ioWorldHello-&gt;say(io_world::Message(), io_world::When::Now); auto lastMessage = ioWorldHello-&gt;last(); auto local_last = io_world::Message(); local_last.m_content = &quot;new message&quot;; ioWorldHello-&gt;setLast(local_last); ioWorldHello-&gt;connect(ioWorldHello.get(), &amp;io_world::AbstractHello::justSaid, [](auto&amp; param){qDebug()&lt;&lt; &quot;received just said&quot;;});   ","version":"Next","tagName":"h3"},{"title":"MQTT Server Adapter​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#mqtt-server-adapter","content":" Files 📜mqtthelloadapter.h and 📜mqtthelloadapter.h contain the mqtt server side adapter for the Hello interface - the MqttHelloAdapter class. When creating the MqttHelloAdapter you need to provide the Apigear::Mqtt::ServiceAdapter and the local AbstractHello service object, you want to expose to clients. MqttHelloAdapter object exposes the local object for remote usage with the MQTT protocol. It handles all the network requests, and calls your local object. The client connections and communication with them is handled transparently for you, no additional actions are needed.  Properties​  Each time a property changed signal (here void lastChanged(const Message&amp; last) ) is emitted, a message is sent to all connected clients with information, which property changed to which value. This may occur either when you change a property directly on your local Hello object, or when a change property request message is received by the MqttHelloAdapter, which applies the property on your local Hello object.  Operations​  The operations invocation which came from the clients through the network will be performed on your local Hello object. The result of the operation (if any) will be returned only to a client, from which the message was send, not all clients.  Signals​  All the signals emitted by your local Hello objects are forwarded to all connected clients.  Use MqttHelloAdapter​  As mentioned earlier, this is an adapter of QtMqtt (with protcol and network layer implementation), here provided by a ApiGear::Mqtt::ServiceAdapterAll you need to do is to pass this ServiceAdapter to your Interface Service Adapter, and request connecting to host when it is convenient for you.   // Prepare the Mqtt Service Adapter and an object which you want to expose. ApiGear::Mqtt::ServiceAdapter service(&quot;ServiceUniqueNameInMqtt&quot;); service.connectToHost(&quot;localhost&quot;, 1883); // Use the same port number as your broker is using. Typically, without any other settings it is &quot;1883&quot;. auto ioWorldHello = std::make_shared&lt;io_world::Hello&gt;(); // Create your MqttHelloAdapter and add it to registry. auto ioWorldMqttHelloService = std::make_shared&lt;io_world::MqttHelloAdapter&gt;(service, ioWorldHello); // use your ioWorldHello implementation, all property changes, and signals will be passed to connected MqttHello clients. auto lastMessage = ioWorldHello-&gt;last(); ioWorldHello-&gt;say(lastMessage, io_world::When::Soon); io_world::Message someMessage; someMessage.m_content = &quot;the new content&quot;; ioWorldHello-&gt;setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value. emit ioWorldHello-&gt;justSaid(someMessage);   ","version":"Next","tagName":"h3"},{"title":"MQTT Factory - for QML usage​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#mqtt-factory---for-qml-usage","content":" Files 📜mqttfactory.h and 📜mqttfactory.cpp contain the MqttFactory which creates the MqttClient version of your interfaces (returned as aAbstractHello interfaces). The factory is necessary when you want to use the MqttClient implementation version for the QML wrapper. You need to set the MqttFactory as an API factory. See more details on providing backend to QML wrapper   // Prepare Factory before app is created. ApiGear::Mqtt::Client client(&quot;UniqueClientForQmlExample&quot;); io_world::MqttFactory io_worldMqttFactory(client); io_world::ApiFactory::set(&amp;io_worldMqttFactory); ... client.connectToHost(&quot;localhost&quot;, 1883);   The factory uses the ApiGear::ObjectLink::OLinkClient and links the objects when they are created, you don't have to perform any other actions.  ... import io_world 1.0 ApplicationWindow { ... Button { width: 80 height: 80 text: qmlIoWorldHello.last.content onClicked: { qmlIoWorldHello.say(someMessage, someWhen) } } IoWorldHello { id: qmlIoWorldHello } ... }   ","version":"Next","tagName":"h3"},{"title":"MQTT Messages​","type":1,"pageTitle":"MQTT","url":"/template-qt6/docs/features/mqtt#mqtt-messages","content":" In case you want construct messages for client or server side on your own, please check how topics are created and how does the payload look like, check this documentS messages format. ","version":"Next","tagName":"h3"},{"title":"Stubs","type":0,"sectionRef":"#","url":"/template-qt6/docs/features/stubs","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"Stubs","url":"/template-qt6/docs/features/stubs#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂implementation ┃ ┃ ┃ ┣ 📂tests ┃ ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┃ ┣ 📜test_hello.cpp ┃ ┃ ┃ ┃ ┗ 📜test_hello.h ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜factory.cpp ┃ ┃ ┃ ┣ 📜factory.h ┃ ┃ ┃ ┣ 📜hello.cpp ┃ ┃ ┃ ┗ 📜hello.h ...   ","version":"Next","tagName":"h3"},{"title":"The Stub​","type":1,"pageTitle":"Stubs","url":"/template-qt6/docs/features/stubs#the-stub","content":" Files 📜hello.h and 📜hello.cpp contain the implementation of the AbstractHello. The class skeleton:  adds the properties of the interface as a private class members - here Message m_lastinitializes them with default values in ctor.defines getters and setters for each propertyprovides empty implementation of operation to implement the business logic.  note We generate the import/export statements - here IO_WORLD_IMPL_EXPORT - for all the classes and structs that have an implementation in a cpp file and may be used outside of the library.  ","version":"Next","tagName":"h3"},{"title":"Factory​","type":1,"pageTitle":"Stubs","url":"/template-qt6/docs/features/stubs#factory","content":" Factory of stub is defined in 📜factory.h and 📜factory.cppThis factory is necessary, when you want to provide this stub implementation to the QML Wrapper. See this api section for full information.  Also have in mind, that using this version of provided pair &quot;factory - stub&quot;, you will not have any handle to interact with a created stub from code. Only changes and interaction will be possible from QML. You could create your version of a factory which also registers the objects to some kind of global registry, which you're able to reach from code.  ","version":"Next","tagName":"h3"},{"title":"Test​","type":1,"pageTitle":"Stubs","url":"/template-qt6/docs/features/stubs#test","content":" For each interface we provide a template for your tests: pair of 📜test_hello.h and 📜test_hello.cpp files with a test class for the interface. It contains 3 kinds of init methods: before each test cases is executed, before first test case is executed and one to create a global data table for tests; For clean up there are 2 methods: one called after each test and one called after last test case is called. There are also slots - initial dummy tests, one for each operation and property. ","version":"Next","tagName":"h3"},{"title":"Template Qt6","type":0,"sectionRef":"#","url":"/template-qt6/docs/intro","content":"Template Qt6 This is the documentation for the Qt6 template. It is split in these parts: Quick-Start is the easiest way to get startedFeatures explains the available code generator features, including what code is generated and why","keywords":"","version":"Next"},{"title":"Template Unreal Engine","type":0,"sectionRef":"#","url":"/template-unreal/docs/intro","content":"Template Unreal Engine This is the documentation for the Unreal Engine template. The documentation is split into the following sections: Quick-Start is the easiest way to get started(coming soon) Features explains the available code generator features, including what code is generated and why","keywords":"","version":"Next"},{"title":"QML Plugin","type":0,"sectionRef":"#","url":"/template-qt6/docs/features/qmlplugin","content":"","keywords":"","version":"Next"},{"title":"File overview for module​","type":1,"pageTitle":"QML Plugin","url":"/template-qt6/docs/features/qmlplugin#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ... ┃ ┃ ┣ 📂qmlplugin ┃ ┃ ┃ ┣ 📜apifactory.cpp ┃ ┃ ┃ ┣ 📜apifactory.h ┃ ┃ ┃ ┗ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜qml_api.cpp ┃ ┃ ┃ ┣ 📜qml_api.h ┃ ┃ ┃ ┣ 📜qmlhello.cpp ┃ ┃ ┃ ┣ 📜qmlhello.h   ","version":"Next","tagName":"h3"},{"title":"QML API​","type":1,"pageTitle":"QML Plugin","url":"/template-qt6/docs/features/qmlplugin#qml-api","content":" To avoid possible namespace collision between different modules we use QML_NAMED_ELEMENT() with module name and element name for all registering objects, like e.g. QML_NAMED_ELEMENT(IoWorldWhen) for When enum.  Files 📜qml_api.h and 📜qml_api.cpp contain:  the enum wrapper for enum registration, which adds only QML macros for registering enum from api library.  struct ForeignWhen : public QObject { Q_OBJECT QML_FOREIGN(When) QML_NAMED_ELEMENT(IoWorldWhen) QML_UNCREATABLE(&quot;This is enum class&quot;) QML_ADDED_IN_VERSION(1,0) };   the factory for uncreatable otherwise in QML structures  class IO_WORLD_QML_EXPORT MessageFactory : public QObject { Q_OBJECT QML_ADDED_IN_VERSION(1,0) QML_NAMED_ELEMENT(IoWorldMessageFactory) QML_SINGLETON public: Q_INVOKABLE io_world::Message create(QString in_content); };   All factories are QML_SINGLETONS, so you don't have to create any instance of it, just call var myInstance = IoWorldMessageFactory.create(...) in your qml code. The create function requires input parameters for all members of the created structure.  note The qml plugin uses the version information form helloworld.module.yaml to register types, both with the QML_ADDED_IN_VERSION and with qt_add_qml_module in CMakeLists.txt. Use this version when importing your module in qml, here import io_world 1.0  ","version":"Next","tagName":"h3"},{"title":"QML Wrappers​","type":1,"pageTitle":"QML Plugin","url":"/template-qt6/docs/features/qmlplugin#qml-wrappers","content":" Files 📜qmlhello.h and 📜qmlhello.cpp contain a qml wrapper for the Hello interface. The qml wrapper requires providing an implemented AbstractHello instance. For that we use the factory described in [api] module with 📜iapifactory.h and implemented in this module in (📜apifactory.h, 📜apifactory.cpp). The functionality is explained below.  The QML wrapper (simplified version)  qmlhello.h class IO_WORLD_QML_EXPORT QMLHello : public AbstractHello { Q_OBJECT QML_NAMED_ELEMENT(IoWorldHello) ... Q_PROPERTY(Message last READ last WRITE setLast NOTIFY lastChanged) ... Q_INVOKABLE int say(const Message&amp; msg, When::WhenEnum when) override; ... Q_SIGNALS: void lastChanged(const Message&amp; last); }   The qml wrapper makes the interface usable from qml: Line 6 shows exposed properties, with emitting signal on property changed from qml (NOTIFY lastChanged) - hence overriding signal for property changed (line 11). Line 8 shows the function exposed as a callable from qml. The wrapper forwards the calls to backend and all the signals from backend to qml wrapper.  caution The signals defined in the api shall be emitted by the backend and handled in qml, not the other way around. When the signal is emitted in qml, it won't reach the backend implementation.  To use QMLHello you just need to create an instance of it in your QML code with a proper name (the one used in QML_NAMED_ELEMENT):  import QtQuick 2.15 import QtQuick.Layouts 1.2 import io_world 1.0 ApplicationWindow { id: appWindow visible: true width: 300 height: 300 IoWorldHello { id: qmlIoWorldHello }   ","version":"Next","tagName":"h3"},{"title":"Providing backend to QML Wrapper.​","type":1,"pageTitle":"QML Plugin","url":"/template-qt6/docs/features/qmlplugin#providing-backend-to-qml-wrapper","content":" The QmlHello is instantiated in qml without any handle to get or set the backend. Therefore, the global ApiFactory class of IApiFactory type is added to provide a flexible and extensible way to create it. The QmlHello class creates the Hello backend object by itself using the global ApiFactory. By providing your IApiFactory implementation, you will be able to use a Hello backend of your choice.  Here is an example code snippet that shows how to prepare your IApiFactory  io_world/customfactory.h #pragma once #include &quot;io_world/api/iapifactory.h&quot; // #include &quot;your CustomHello header file&quot; #include &lt;QtCore&gt; class CustomFactory : public QObject, public IApiFactory { public: CustomFactory(..., QObject *parent = nullptr); //provide any extra resources your factory needs. std::shared_ptr&lt;AbstractHello&gt; createHello(QObject *parent = nullptr) override { return make_shared&lt;CustomHello&gt;(...); // provide any resource your CustomHello needs. } };   and set in code  main.cpp #include &quot;io_world/api/apifactory.h&quot; #include &quot;io_world/customfactory.h&quot; #include &lt;QtCore&gt; #include &lt;QGuiApplication&gt; #include &lt;QQmlApplicationEngine&gt; int main(int argc, char *argv[]){ io_world::CustomFactory io_worldFactory(); // Setting the CustomFactory as a global factory. From now, each qml object will create backend with it. io_world::ApiFactory::set(&amp;io_worldFactory); // Starting your application after setting the factory. const QUrl url(QStringLiteral(&quot;qrc:/main.qml&quot;)); QGuiApplication app(argc, argv); QQmlApplicationEngine engine; engine.load(url); ...   this way, on every QmlHello instantiation, your CustomFactory::createHello is called, and the returned object is used by QmlHello.  note You can check the qml example or factories provided by other features. For instance olink.  caution Your IApiFactory implementation needs to be set to ApiFactory once, before the QML file is loaded.  ","version":"Next","tagName":"h3"},{"title":"Paths​","type":1,"pageTitle":"QML Plugin","url":"/template-qt6/docs/features/qmlplugin#paths","content":" If you run your application outside of Qt Creator you need to add the import paths (paths where the plugins are) to runtime. You can either set the QML_IMPORT_PATH and QML2_IMPORT_PATH environment variables - for ad-hoc import paths (for debugging or testing) or use the QQmlEngine::addImportPath() function for fixed import paths that should always be available.   QGuiApplication app(argc, argv); QQmlApplicationEngine engine; app.addLibraryPath(the-directory);   Usually the plugins are located in your CMAKE_BINARY_DIR in the target folder. In our example code that would be &quot;your-build-dir/io/world/qmlplugin&quot; folder.  Read more on import paths ","version":"Next","tagName":"h3"},{"title":"Quick-Start","type":0,"sectionRef":"#","url":"/template-qt6/docs/quickstart","content":"","keywords":"","version":"Next"},{"title":"1. Install the code generator​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#1-install-the-code-generator","content":" Get the ApiGear Studio or ApiGear CLI. For more information check the ApiGear documentation.  ","version":"Next","tagName":"h2"},{"title":"2. Get the template​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#2-get-the-template","content":" There are several options to get the template. Installation via the Studio or the CLI. Alternatively it is possible to clone or download from github.  ","version":"Next","tagName":"h2"},{"title":"Installation via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#installation-via-cli","content":" When using the CLI only the highlighted line is imported. You can always check whether the installation was successful via the template list command.  $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-qtcpp | false | true | https://github.com/apigear-io/template-qtcpp.git ... $ apigear template install apigear-io/template-qtcpp $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-qtcpp | true | true | https://github.com/apigear-io/template-qtcpp.git ...   ","version":"Next","tagName":"h3"},{"title":"Installation via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#installation-via-studio","content":" From within the studio the installation is really simple.  Open an existing project or create an new oneGo to the Templates tabClick Install on the apigear-io/template-qtcpp entry  ","version":"Next","tagName":"h3"},{"title":"Clone from github​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#clone-from-github","content":" In case you want to check or modify the source code of the template, it is easier to clone or download the repository. The repository does not need to be part of the project, but can be stored anywhere on the computer.  $ git clone https://github.com/apigear-io/template-qtcpp.git   ","version":"Next","tagName":"h3"},{"title":"3. Set up project​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#3-set-up-project","content":" For a project we usually need two files. The solution which specifies what APIs and which template to use for it. And at least one API module file. Both should ideally be in a folder called apigear next to each other.  Alternatively, you can also use the Studio to create a new project and modify the two example files.  ","version":"Next","tagName":"h2"},{"title":"Solution file​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#solution-file","content":" Create a solution file. The example below specifies  module files in line 8, here the helloworld.module.yaml module with Hello APIthe output directory for generated files in line 9a template used to generate the code in line 10, here the apigear-ui/template-qtcpp template. This can also be a path to a local copy of the template.the enabled features of the template in line 13, here the stubs feature, a simple implementation of interfaces. For all available features check the overview.  helloworld.solution.yaml schema: &quot;apigear.solution/1.0&quot; name: hello_world_example version: &quot;0.1.0&quot; targets: - name: qt_hello_world inputs: - helloworld.module.yaml output: ../qt_hello_world template: apigear-io/template-qtcpp force: true features: - stubs   Targets You can extend this solution file with other targets, each for the different technology with different template. The module.yaml is technology independent and may be used for any template.  note Set the force parameter to true if you want to always override all the generated files. With option set to false some files, like implementation (stub feature) won't be updated. All the API files are always updated.  ","version":"Next","tagName":"h3"},{"title":"API module file​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#api-module-file","content":" Use your favorite text editor to create the helloworld.module.yaml with the example content:  helloworld.module.yaml schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"4. Generate code​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#4-generate-code","content":" With the output directory set as in example, both ApiGear files reside in an apigear subfolder next to the Qt generated files. In this case the folder structure should look similar to this  📂hello-world ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂qt_hello_world ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┗ 📂implementation ┃ ┗ 📜CMakeLists.txt   Using the solution file from the previous paragraph the code will be generated in the qt_hello_world folder. With subfolder for each module, here io_world as the name of module (defined in line 2 of helloworld.module.yaml). It contains both features generated: a basic api and a stub implementation.  ","version":"Next","tagName":"h2"},{"title":"Generate via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#generate-via-cli","content":" The following snippet shows how the CLI can be run.  $ apigear generate solution apigear/helloworld.solution.yaml 10:52:20 INF generated 21 files in 30ms. (20 write, 0 skip, 1 copy) topic=gen   generate tells the CLI that it should generate codesolution specifies that we want to run a solution file  ","version":"Next","tagName":"h3"},{"title":"Generate via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#generate-via-studio","content":" Open the projectGo to the Solutions tabClick Run on the helloworld.solution.yaml entry  ","version":"Next","tagName":"h3"},{"title":"5. Use the generated Qt project.​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#5-use-the-generated-qt-project","content":" The generated code provides Qt C++ implementations. The following paragraphs show how you can use it. You can start your project loading the top level CMakeLists.txt in qt_hello_world folder.  The 'api.h' contains all definitions of the enums and structs for your module, as well as the QObject abstract base classes for your Interfaces. From now on you can simply include the header files for the api interface or the stub implementation and use it. For more details on generated features please check api, stubs.  tip Check the &quot;example&quot; and qmlplugin features to see how to use your API directly in qml with the generated wrappers.  note For the pure virtual interface see the pure C++ template  note For the simulation check the olink feature which provides middle layer on your code side and the simulation explained.  ","version":"Next","tagName":"h2"},{"title":"Create and run an example​","type":1,"pageTitle":"Quick-Start","url":"/template-qt6/docs/quickstart#create-and-run-an-example","content":" Prepare an examples folder in the hello-world/qt_hello_world directory with a main.cpp like this:  #include &lt;QGuiApplication&gt; #include &quot;io_world/implementation/hello.h&quot; int main(int argc, char *argv[]) { QGuiApplication app(argc, argv); io_world::Hello myHelloInstance; // Try out properties: subscribe for changes myHelloInstance.connect(&amp;myHelloInstance, &amp;io_world::AbstractHello::lastChanged, []( const io_world::Message&amp; last){ qDebug() &lt;&lt; &quot;last property changed &quot;;}); // and ask for change. io_world::Message messageForProperty; messageForProperty.m_content = QString(&quot;New message&quot;); myHelloInstance.setLast(messageForProperty); // Check the signals with subscribing for its change myHelloInstance.connect(&amp;myHelloInstance, &amp;io_world::AbstractHello::justSaid, [](const io_world::Message&amp; msg){ qDebug() &lt;&lt; &quot;justSaid signal emitted &quot;;}); // and emit one. io_world::Message messageForSignal; messageForSignal.m_content = QString(&quot;Message from signal&quot;); emit myHelloInstance.justSaid(messageForSignal); // Play around executing operations, maybe they emit signals? or change the properties? auto method_result = myHelloInstance.say(io_world::Message(), io_world::When::Now); return app.exec(); }   add a CMakeLists.txt  project(MyExample) cmake_minimum_required(VERSION 3.20) find_package(Qt6 REQUIRED COMPONENTS Gui) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED ON) add_executable(MyExample main.cpp) find_package(io_world QUIET COMPONENTS io_world_impl) target_link_libraries(MyExample io_world_impl Qt6::Gui)   Add the example subdirectory to the hello-world/qt_hello_world/CMakeLists.txt. Now you can build the application and the libraries with it and run your example. ","version":"Next","tagName":"h3"},{"title":"Olink","type":0,"sectionRef":"#","url":"/template-qt6/docs/features/olink","content":"","keywords":"","version":"Next"},{"title":"Apigear ObjectLink protocol and ObjectLink core library​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#apigear-objectlink-protocol-and-objectlink-core-library","content":" The ObjectLink protocol is a lightweight protocol for the Objects described with an interface. It allows connecting a client object with a server object, and perform remote operations like: remote property change request (client) or notifications on property changed (server), inform about signal emission (server) and allows requesting a call of a method (client) and giving a response to the outcome (server).  The Olink feature for your interface uses a library ObjectLink core, common for cpp based templates. The provided CMakeLists already contain all the dependencies, so you don't have to add it manually.  The library provides an abstraction layer for handling the protocol, independent of the actual network stack. It encodes and decodes the messages and routes them to corresponding objects stored in its registry. The setup is minimal: instantiate the registries (for client and/or server) and pass them to network layer objects in qt apigear library  caution In this library we use STL classes in public interfaces. We assume that this library is built from source (configuration provided by generated CMakeLists). Otherwise, it has to be ensured that your build configuration matches the library build configuration.  ","version":"Next","tagName":"h3"},{"title":"File overview for module​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#file-overview-for-module","content":" With an example API  Hello World API (click to expand) schema: apigear.module/1.0 name: io.world version: &quot;1.0.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   the following file structure will be generated. The purpose and content of each file is explained below.  📂hello-world ┣ 📂apigear ┃ ... ┣ 📂qt_hello_world ┃ ┣ 📂apigear ┃ ┃ ┣ 📂monitor ┃ ┃ ┣ 📂olink ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜olinkclient.cpp ┃ ┃ ┃ ┣ 📜olinkclient.h ┃ ┃ ┃ ┣ 📜olinkhost.cpp ┃ ┃ ┃ ┣ 📜olinkhost.h ┃ ┃ ┃ ┣ 📜olinkremote.cpp ┃ ┃ ┃ ┗ 📜olinkremote.h ┃ ┃ ... ┃ ┣ 📂examples ┃ ┣ 📂io_world ┃ ┃ ┣ 📂api ┃ ┃ ┣ 📂implementation ┃ ┃ ┣ 📂olink ┃ ┃ ┃ ┣ 📜CMakeLists.txt ┃ ┃ ┃ ┣ 📜olinkfactory.cpp ┃ ┃ ┃ ┣ 📜olinkfactory.h ┃ ┃ ┃ ┣ 📜olinkhello.cpp ┃ ┃ ┃ ┣ 📜olinkhello.h ┃ ┃ ┃ ┣ 📜olinkhelloadapter.cpp ┃ ┃ ┃ ┗ 📜olinkhelloadapter.h ...   ","version":"Next","tagName":"h2"},{"title":"Qt apigear - The Network Layer​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#qt-apigear---the-network-layer","content":" When generating the olink feature (or monitor feature) you'll get an additional folder it the top most directory: the 📂hello-world/📂apigear. The 📂olink subfolder contains objects that implement a network layer (based on QtWebSocket library) for the ObjectLink protocol. Those are:  OlinkClient - the client, that serves your interface client adapters. The class is responsible for network connection for ObjectLink client side. It uses the ObjectLink core library for handling messages according to the ObjectLink protocol. Handles linking and unlinking with a remote service for the sink added by the user (the interface OlinkClient Adapters), with regard to the connection state. All the messages dedicated to your object will be delivered to the adapter and proper actions will be performed for the clients that use it, without any of your actions. Also the OlinkClient holds a message queue for messages during disconnected time.OlinkHost and a helper class OlinkRemote- the server, which hosts your services exposed to network through the interface server adapters. The class is responsible to set up the server and manage connections requested by clients. It uses ObjectLink core library for handling messages according to the ObjectLink protocol. All incoming messages will be translated to calls and routed to your local object.  ","version":"Next","tagName":"h3"},{"title":"Olink Client Adapter​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#olink-client-adapter","content":" Files 📜olinkhello.h and 📜olinkhello.cpp contain the olink client version of the Hello interface - an OLinkHello class. It implements two interfaces: AbstractHello and a IObjectSink. The IObjectSink interface comes from ObjectLink core:  IObjectSink (click to expand) class IObjectSink { public: virtual std::string olinkObjectName() = 0; virtual void olinkOnSignal(const std::string&amp; signalId, const nlohmann::json&amp; args) = 0; virtual void olinkOnPropertyChanged(const std::string&amp; propertyId, const nlohmann::json&amp; value) = 0; virtual void olinkOnInit(const std::string&amp; objectId, const nlohmann::json&amp; props, IClientNode* node) = 0; virtual void olinkOnRelease() = 0; };   and is necessary for handling incoming messages from the server side and is used by a OlinkClient (Qt Apigear Olink lib). Apart from setting up and tear down of the OLinkHello object, you don't need to perform any additional actions, the object OLinkHello will communicate with the server transparently and you should use it as an AbstractHello Object only.  Properties​  The property getters (here Message last() ) return immediately the locally stored last received value from server. The property setter (here void setLast(const Message&amp; last) ) requests setting a value on server side, local value is not changed. You can connect to a property changed signals (here void lastChanged(const Message&amp; last) ) When the client receives information that server changed the property, a target property (here last) is updated locally and a signal that property has changed is emitted ( here void lastChanged(const Message&amp; last).  note The connected client has its local properties initialized - on a successful linking client with server the client receives the init message, which contains current state of properties of the service on server side.  Operations​  The operations have additionally the async version, which is called by the immediate version. The async version sends an invoke operation request to a server. So calling myOlinkHelloInstance.say(myWhen) implements execution of sayAsync and waits for the result (for non-void type of operations). Have in mind that this is a blocking operation.  Signals​  You should not emit any signals from a client. You can connect to any signals offered by your interface (here void justSaid(const Message&amp; msg) ) When a OlinkHello client receives the olinkOnSignal, a signal (here justSaid) is emitted.  Use OLinkHello​  As mentioned earlier you need a network layer, here provided by a ApiGear::ObjectLink::OLinkClient which also contains the protocol handling ClientNode. All you need to do is give it a global ApiGear::ObjectLink::ClientRegistry, request connecting to host when it is convenient for you and then add your OlinkHello.   // Create a global registry. ApiGear::ObjectLink::ClientRegistry registry; // Create a client and make a connection ApiGear::ObjectLink::OLinkClient client(registry); client.connectToHost(QUrl(&quot;ws://127.0.0.1:8182&quot;)); // Create your service client and request it linking, which will try to connect with a server side for this object. auto ioWorldHello = std::make_shared&lt;io_world::OLinkHello&gt;(); client.linkObjectSource(ioWorldHello); // use your ioWorldHello as it was Hello implementation ioWorldHello-&gt;say(io_world::Message(), io_world::When::Now); auto lastMessage = ioWorldHello-&gt;last(); auto local_last = io_world::Message(); local_last.m_content = &quot;new message&quot;; ioWorldHello-&gt;setLast(local_last); ioWorldHello-&gt;connect(ioWorldHello.get(), &amp;io_world::AbstractHello::justSaid, [](auto&amp; param){qDebug()&lt;&lt; &quot;received just said&quot;;}); // remember to unlink your object if you won't use it anymore. client.unlinkObjectSource(ioWorldHello-&gt;olinkObjectName());   caution ApiGear::ObjectLink::ClientRegistry can have only one object of a certain type. This means that, to have more than one 'OlinkHello' objects you need to put them in different registries. Each Object has an identifier which is created based on the Interface Name, this way client object can be matched with proper server object.  ","version":"Next","tagName":"h3"},{"title":"Olink Server Adapter​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#olink-server-adapter","content":" Files 📜olinkhelloadapter.h and 📜olinkhelloadapter.h contain the olink server adapter for the Hello interface - the OLinkHelloAdapter class. It implements an IObjectSource interface (from ObjectLink core), which wraps your Hello and exposes it for remote usage with the ObjectLink protocol. It handles all the network requests, and calls your local object. When creating the OLinkHelloAdapter you need to provide the local AbstractHello service object, you want to expose to clients.  The IObjectSource interface:  IObjectSource (click to expand) class IObjectSource { public: virtual std::string olinkObjectName() = 0; virtual nlohmann::json olinkInvoke(const std::string&amp; methodId, const nlohmann::json&amp; args) = 0; virtual void olinkSetProperty(const std::string&amp; propertyId, const nlohmann::json&amp; value) = 0; virtual void olinkLinked(const std::string&amp; objectId, IRemoteNode* node) = 0; virtual void olinkUnlinked(const std::string&amp; objectId) = 0; virtual nlohmann::json olinkCollectProperties() = 0; };   After setting up the OlinkHost (Qt Apigear Olink lib) and registering your Interface registered, the client connections and communication with them is handled transparently for you, no additional actions are needed.  note All the received messages from the clients are handled in a thread in which the connection resides, this means that your object may be used from different threads (local and each connection).  Properties​  Each time a property changed signal (here void lastChanged(const Message&amp; last) ) is emitted, a message is sent to all connected clients with information, which property changed to which value. This may occur either when you change a property directly on your local Hello object, or when a change property request message is received by the OLinkHelloAdapter, which applies the property on your local Hello object.  Operations​  The operations invocation which came from the clients through the network will be performed on your local Hello object. The result of the operation (if any) will be returned only to a caller, not all clients. Have in mind that your object may be called from more that one thread.  Signals​  All the signals emitted by your local Hello objects are forwarded to all connected clients.  Use OLinkHelloAdapter​  As mentioned earlier you need a network layer, here provided by a ApiGear::ObjectLink::OLinkHost (The ApiGear::ObjectLink::OLinkRemote objects are created automatically per connection) which also contains the protocol handling RemoteNodes. All you need to do is give a global ApiGear::ObjectLink::RemoteRegistry with your OLinkHelloAdapter in it to ApiGear::ObjectLink::OLinkHost.   // Prepare the registry, the server, and an object which you want to expose. ApiGear::ObjectLink::RemoteRegistry registry; ApiGear::ObjectLink::OLinkHost server(registry); server.listen(&quot;localhost&quot;, 8182); auto ioWorldHello = std::make_shared&lt;io_world::Hello&gt;(); // Create your OLinkHelloAdapter and add it to registry. auto ioWorldOlinkHelloService = std::make_shared&lt;io_world::OLinkHelloAdapter&gt;(registry, ioWorldHello.get()); registry.addSource(ioWorldOlinkHelloService); // use your ioWorldHello implementation, all property changes, and signals will be passed to connected OLink clients. auto lastMessage = ioWorldHello-&gt;last(); ioWorldHello-&gt;say(lastMessage, io_world::When::Soon); io_world::Message someMessage; someMessage.m_content = &quot;the new content&quot;; ioWorldHello-&gt;setLast(someMessage); // after this call - if new property is different than current one - all clients will be informed about new value. emit ioWorldHello-&gt;justSaid(someMessage); // Remember to remove your ioWorldOlinkHelloService after you finish using it. registry.removeSource(ioWorldOlinkHelloService-&gt;olinkObjectName());   ","version":"Next","tagName":"h3"},{"title":"Olink Factory - for QML usage​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#olink-factory---for-qml-usage","content":" Files 📜olinkfactory.h and 📜olinkfactory.cpp contain the OLinkFactory which creates the OlinkClient version of your interfaces (returned as aAbstractHello interfaces). The factory is necessary when you want to use the OlinkClient implementation version for the QML wrapper. You need to set the OlinkFactory as an API factory. See more details on providing backend to QML wrapper   // Prepare Factory before app is created. ApiGear::ObjectLink::ClientRegistry client_registry; ApiGear::ObjectLink::OLinkClient client(client_registry); io_world::OLinkFactory io_worldOlinkFactory(client); io_world::ApiFactory::set(&amp;io_worldOlinkFactory); ... // Connect the client - all qml olink clients will be linked if the server services are already up. client.connectToHost(QUrl(&quot;ws://127.0.0.1:8182&quot;));   The factory uses the ApiGear::ObjectLink::OLinkClient and links the objects when they are created, you don't have to perform any other actions.  ... import io_world 1.0 ApplicationWindow { ... Button { width: 80 height: 80 text: qmlIoWorldHello.last.content onClicked: { qmlIoWorldHello.say(someMessage, someWhen) } } IoWorldHello { id: qmlIoWorldHello } ... }   ","version":"Next","tagName":"h3"},{"title":"Simulation​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#simulation","content":" The simulation can be used to test, demonstrate or develop applications without the need to have the actual service available. The simulation server is integrated into the ApiGear studio and the CLI.  For simulating you will use simulation scenarios They allow to define sequences of actions. The actions can change the property values of the service or emit signals. The scenarios can be written using a YAML schema.  See more on simulation.  ","version":"Next","tagName":"h2"},{"title":"Prepare your application​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#prepare-your-application","content":" Make sure you are using OlinkClient as your Hello object, either:  instance on cpp sideor qml version and connect to the same url and port that you configure in the ApiGear studio.  You may try our example - copy the code into new folder in generated examples folder This is an example with qml version of using OlinkClient.  main.cpp​  The main.cpp sets up the qml factory  main.cpp (click to expand) #include &quot;io_world/api/apifactory.h&quot; #include &quot;io_world/olink/olinkfactory.h&quot; #include &quot;io_world/monitor/tracedapifactory.h&quot; #include &lt;QtCore&gt; #include &quot;olink/clientregistry.h&quot; #include &lt;QGuiApplication&gt; #include &lt;QQmlApplicationEngine&gt; #include &quot;olink/olinkclient.h&quot; #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;QtPlugin&gt; int main(int argc, char *argv[]){ // Prepare Factory before app is created. ApiGear::ObjectLink::ClientRegistry client_registry; ApiGear::ObjectLink::OLinkClient client(client_registry); io_world::OLinkFactory io_worldOlinkFactory(client); io_world::ApiFactory::set(&amp;io_worldOlinkFactory); // Create main app const QUrl url(QStringLiteral(&quot;qrc:/main.qml&quot;)); QGuiApplication app(argc, argv); QQmlApplicationEngine engine; engine.load(url); // Connect the client - all qml olink clients will be linked client.connectToHost(QUrl(&quot;ws://127.0.0.1:8182/ws&quot;)); auto result = app.exec(); return result; }   note Make sure to configure the client to use the correct IP and port configuration of your simulation server e.g. set client.connectToHost(QUrl(&quot;ws://127.0.0.1:8182/ws&quot;));  main.qml​  As a starting point, describes 3 buttons, which are connected to:  Usage of method - on click, it executes the method (request to server) and shows the outcome as a button text.Binding to a property - text of button 2Binding to a signal outcome - text of button 3  with a following code  main.qml(click to expand) import QtQuick 2.15 import QtQuick.Layouts 1.2 import QtQuick.Controls 2.15 import io.world 1.0 import io.world.MessageFactorySingleton 1.0 ApplicationWindow { id: appWindow visible: true width: 300 height: 250 ColumnLayout { spacing: 10 id: mainLayout anchors.fill: parent Button { id: button1 Layout.alignment: Qt.AlignCenter background: Rectangle { implicitWidth: 250 implicitHeight: 50 radius: 4 color: &quot;#9ed545&quot; } text: &quot;Click to get result of a method&quot; onClicked: { var msg = IoWorldMessageFactory.create() msg.content = &quot;some message&quot; qmlIoWorldHello.say(msg, IoWorldWhen.New) } } Button { id: button2 Layout.alignment: Qt.AlignCenter background: Rectangle { implicitWidth: 250 implicitHeight: 50 radius: 4 color: &quot;#9ed545&quot; } text: qmlIoWorldHello.last.content onClicked: { console.log(&quot;Or events like changing properties or invoking methods&quot;) } } Button { id: button3 Layout.alignment: Qt.AlignCenter background: Rectangle { implicitWidth: 250 implicitHeight: 50 radius: 4 color: &quot;#9ed545&quot; } text: &quot;Will show singal message&quot; } } IoWorldHello { id: qmlIoWorldHello onJustSaid:{ console.log(&quot;signal received&quot;) button3.text = msg.content } } }   you should get an app like this  Figure: Testing application used with the simulation.  CMakeLists.txt and resource.qrc​  CMakeLists.txt(click to expand) project(QmlExamlple) cmake_minimum_required(VERSION 3.20) # append local binary directory for conan packages to be found set(CMAKE_MODULE_PATH ${CMAKE_BINARY_DIR} ${CMAKE_MODULE_PATH}) set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED ON) set (SOURCES main.cpp main.qml resources.qrc ) set(QML_IMPORT_PATH &quot;${CMAKE_BINARY_DIR}/imports&quot; CACHE STRING &quot;&quot; FORCE) set(QML2_IMPORT_PATH &quot;${CMAKE_BINARY_DIR}/imports&quot; CACHE STRING &quot;&quot; FORCE) add_executable(QmlExamlple ${SOURCES} ) find_package(Qt5 REQUIRED COMPONENTS Core Qml Network WebSockets Gui Quick QuickControls2 QuickWidgets) find_package(apigear QUIET COMPONENTS olink_qt) find_package(apigear QUIET COMPONENTS olink_core) if(NOT olink_core_FOUND) # pull objectlink-core-cpp as dependency message(STATUS &quot;objectlink-core-cpp NOT FOUND, fetching the git repository&quot;) FetchContent_Declare(olink_core GIT_REPOSITORY https://github.com/apigear-io/objectlink-core-cpp.git GIT_TAG v0.2.4 GIT_SHALLOW TRUE EXCLUDE_FROM_ALL FALSE ) FetchContent_MakeAvailable(olink_core) endif() find_package(io_world QUIET COMPONENTS io_world_api io_world_impl io_world_olink plugin_io_world io_world_monitor) target_link_libraries(QmlExamlple io_world_api io_world_impl io_world_olink plugin_io_world io_world_monitor Qt5::Core Qt5::Qml Qt5::WebSockets Qt5::Gui Qt5::Quick Qt5::QuickControls2 Qt5::QuickWidgets olink_qt olink_core ) install(TARGETS QmlExamlple RUNTIME DESTINATION bin COMPONENT Runtime)   resources.qrc(click to expand) &lt;RCC&gt; &lt;qresource prefix=&quot;/&quot;&gt; &lt;file&gt;main.qml&lt;/file&gt; &lt;/qresource&gt; &lt;/RCC&gt;   ","version":"Next","tagName":"h3"},{"title":"Prepare the scenario​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#prepare-the-scenario","content":" As a starting point you can check our simulation scenario:  Scenario(click to expand) schema: apigear.scenario/1.0 name: &quot;first scenario&quot; version: &quot;1.0.0&quot; #initial properties and setting gunction response interfaces: - name: io.world.Hello #( module io.world and interface Hello combination) properties: last: {content: &quot;Initial&quot;} operations: - name: say actions: - $return: { value: 88 } # sequence of changing properties and emitting signals sequences: - name: play with hello interval: 2000 # 2 seconds interface: io.world.Hello loops: 3 steps: # step is called every 2 secs according to interval - name: change property actions: - $set: { last: {content: &quot;First Change of Property&quot;} } - name: emit signal actions: - $signal: { justSaid: [ {content: &quot;First Message&quot;} ] } - name: change property AND emit signal actions: - $set: { last: {content: &quot;Second Change of Property&quot;} } - $signal: { justSaid: [ {content: &quot;Other Signal&quot;} ] }   Apart from the header with the scenario name and its version it consists of two parts:  initialization - for each interface (here, our ui.world.Hello line 6), we're setting initial values of properties(line 8) and the return value of function calls (line 12)sequence of events. You can prepare more than one sequence. For each of them set interval between calling each action (line 16), set how many runs of that sequence you want to execute (line 18) and name the interface the action should be applied to (line 17). In each action you may change many properties, and emit signals.  ","version":"Next","tagName":"h3"},{"title":"Run the simulation​","type":1,"pageTitle":"Olink","url":"/template-qt6/docs/features/olink#run-the-simulation","content":" Put your scenario file in the 📂hello-world/apigear along with other .yaml files. If you are using the studio, reload your project. Go to settings and make sure to set same the port as in your client app (here 8182). Click the play button in the application in the simulation tab to start the simulation scenario, then start the client application.  Instead of the Apigear Studio application can also use its console version, run your scenario with command:  apigear simulate run path-from-cli-to-scenario/helloworldtest.scenario.yaml --addr :8182  ","version":"Next","tagName":"h3"},{"title":"Quick-Start","type":0,"sectionRef":"#","url":"/template-unreal/docs/quickstart","content":"","keywords":"","version":"Next"},{"title":"1. Install the code generator​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#1-install-the-code-generator","content":" Get ApiGear Studio or ApiGear CLI. For more information check the ApiGear documentation.  ","version":"Next","tagName":"h2"},{"title":"2. Get the template​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#2-get-the-template","content":" There are several options to get the template. Installation via the Studio or the CLI. Alternatively it is possible to clone or to download it directly from github.  ","version":"Next","tagName":"h2"},{"title":"Installation via ApiGear CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#installation-via-apigear-cli","content":" You can install the template with apigear template install apigear-io/template-unreal. And you can always check whether installation was successful via the template list command.  $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-unreal | false | true | https://github.com/apigear-io/template-unreal.git ... $ apigear template install apigear-io/template-unreal $ apigear template list list of templates from registry and cache name | installed | registry | url apigear-io/template-unreal | true | true | https://github.com/apigear-io/template-unreal.git ...   When using the CLI for installation only the highlighted line is imported.  ","version":"Next","tagName":"h3"},{"title":"Installation via ApiGear Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#installation-via-apigear-studio","content":" From within the studio the installation is really simple.  Open an existing project or create an new oneGo to the Templates tabClick Install on the apigear-io/template-unreal entry  Figure: Install the unreal template  ","version":"Next","tagName":"h3"},{"title":"Clone from github​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#clone-from-github","content":" In case you want to check or modify the source code of the template, it is easier to clone or download the repository. The repository does not need to be part of the project, but can be stored anywhere on the computer.  $ git clone https://github.com/apigear-io/template-unreal.git   ","version":"Next","tagName":"h3"},{"title":"3. Set up an ApiGear project​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#3-set-up-an-apigear-project","content":" For a project we need two files. Both should be in a folder called apigear next to each other.  The solution file which specifies what APIs and which template to use for it.And at least one API module file.  Those files can be created manually or alternatively, one can also use the Studio to create a new project and modify the two example files.  ","version":"Next","tagName":"h2"},{"title":"Solution file​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#solution-file","content":" Create a solution file. The example below specifies  the helloworld.module.yaml which contains the API in line 8the output directory in line 9the apigear-ui/template-unreal to be used in line 10. This can also be a path to a local copy of the template.enables the stubs feature of the template, a simple implementation in line 13.  helloworld.solution.yaml schema: &quot;apigear.solution/1.0&quot; name: ue_docs version: &quot;0.1&quot; layers: - name: ue_docs inputs: - helloworld.module.yaml output: ../ue_docs template: apigear-io/template-unreal force: true features: - stubs   ","version":"Next","tagName":"h3"},{"title":"API module file​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#api-module-file","content":" Use your favorite text editor to create the helloworld.module.yaml with the example content:  helloworld.module.yaml schema: apigear.module/1.0 name: io.world version: &quot;1.0&quot; interfaces: - name: Hello properties: - { name: last, type: Message } operations: - name: say params: - { name: msg, type: Message } - { name: when, type: When } return: type: int signals: - name: justSaid params: - { name: msg, type: Message } enums: - name: When members: - { name: Now, value: 0 } - { name: Soon, value: 1 } - { name: Never, value: 2 } structs: - name: Message fields: - { name: content, type: string }   ","version":"Next","tagName":"h3"},{"title":"4. Generate code​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#4-generate-code","content":" For the code generation we assume that both ApiGear files reside in an apigear subfolder next to the Unreal Engine project. In this case the folder structure should look similar to this.  📦ue_docs_example_project ┣ 📂apigear ┃ ┣ 📜helloworld.solution.yaml ┃ ┗ 📜helloworld.module.yaml ┣ 📂ue_docs ┃ ┣ 📂Config ┃ ┣ 📂Content ┃ ┣ 📂Platforms ┃ ┣ 📂Plugins ┃ ┣ 📂Source ┃ ┗ 📜ue_docs.uproject   Using the the solution file from the previous paragraph the code will be generated in the ue_docs/Plugins folder.  ","version":"Next","tagName":"h2"},{"title":"Generate via CLI​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#generate-via-cli","content":" The following snippet shows how to generate code using the CLI.  $ apigear generate solution apigear/helloworld.solution.yaml 17:52:20 INF generated 92 files in 30ms. (33 write, 0 skip, 59 copy) topic=gen   generate tells the CLI that it should generate codesolution specifies that we want to run a solution file  ","version":"Next","tagName":"h3"},{"title":"Generate via Studio​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#generate-via-studio","content":" Open the projectGo to the Solutions tabClick Run on the helloworld.solution.yaml entry  Figure: Generate code  ","version":"Next","tagName":"h3"},{"title":"5. How to use the plugin​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#5-how-to-use-the-plugin","content":" The generated code can be used with Blueprints and C++. The following paragraphs show how this can be achieved. Make sure to have the generated plugin code in your projects plugins directory as noted in the previous section.  ","version":"Next","tagName":"h2"},{"title":"Blueprint​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#blueprint","content":" Open your project in the Unreal Editor and choose a Blueprint where you want to use the interface. In this Blueprint we first get the GameInstance subsystem of the type Io World Hello.  Figure: Get subsystem in blueprint  On this subsystem we can choose the asynchronous say function.  Figure: Choose method on interface in blueprint  The complete setup to say &quot;Hello world&quot; on begin play.  Figure: Hello interface example in blueprint  ","version":"Next","tagName":"h3"},{"title":"C++​","type":1,"pageTitle":"Quick-Start","url":"/template-unreal/docs/quickstart#c","content":" Since the generated interface is used outside of its own module, we have to add the module identifier to the list of dependency modules in the dependent module e.g. your project's or another plugin's module. To do this, open the dependents module, e.g. ue_docs.Build.cs, and add IoWorld to the PublicDependencyModuleNames. IoWorld is the demo module's name in the example.  ue_docs.Build.cs PublicDependencyModuleNames.AddRange(new string[] { &quot;Core&quot;, &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;InputCore&quot;, &quot;IoWorld&quot; });   Afterwards, we can simply include the header files for the api interface, the stub implementation and use it.  ue_docsGameModeBase.cpp #include &quot;ue_docsGameModeBase.h&quot; #include &quot;Implementation/IoWorldHello.h&quot; #include &quot;Generated/api/IoWorld_data.h&quot; #include &quot;Generated/api/IoWorldHelloInterface.h&quot; void Aue_docsGameModeBase::InitGame(const FString&amp; MapName, const FString&amp; Options, FString&amp; ErrorMessage) { Super::InitGame(MapName,Options, ErrorMessage); TScriptInterface&lt;IIoWorldHelloInterface&gt; HelloWorldObjPtr = GetGameInstance()-&gt;GetSubsystem&lt;UIoWorldHello&gt;(); FIoWorldMessage MyMsg; MyMsg.content = FString(&quot;Hello world&quot;); HelloWorldObjPtr-&gt;Say(MyMsg, EIoWorldWhen::IWW_NOW); }  ","version":"Next","tagName":"h3"}],"options":{"highlightResult":true,"id":"default"}}